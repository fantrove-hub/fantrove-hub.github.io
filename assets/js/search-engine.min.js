let apiData = null;
let currentResults = [];
let filterCategories = [];
let selectedType = 'all';
let selectedCategory = 'all';
let debounceTimeout = null;
let allKeywordsCache = [];
let emojiSuggestionsCache = [];
let symbolSuggestionsCache = [];

// ภาษา (รองรับหลายภาษา)
const LANG_TEXTS = {
    th: {
        all_types: "ทุกประเภท",
        all_categories: "ทุกหมวดหมู่",
        not_found: "ไม่พบข้อมูลที่ตรงหรือใกล้เคียงกับคำค้นของคุณ",
        copy: "คัดลอก",
        suggestions_for_you: "แนะนำสำหรับคุณ",
        emoji_suggestions: "แนะนำอีโมจิ",
        symbol_suggestions: "แนะนำสัญลักษณ์พิเศษ",
        type: "ประเภท",
        category: "หมวดหมู่",
        emoji: "อีโมจิ",
        symbol: "สัญลักษณ์",
        predicted: "คาดคะเนจากคำค้น",
        typo: "แนะนำจากคำที่อาจสะกดผิด",
        emoji_suggestion_cat: "แนะนำอีโมจิ",
        symbol_suggestion_cat: "แนะนำสัญลักษณ์",
        search_placeholder: "ค้นหาบน FanTrove",
        search_result_here: "ผลการค้นหาจะแสดงที่นี่"
    },
    en: {
        all_types: "All Types",
        all_categories: "All Categories",
        not_found: "No data found related to your keyword.",
        copy: "Copy",
        suggestions_for_you: "Suggestions For You",
        emoji_suggestions: "Emoji Suggestions",
        symbol_suggestions: "Special Symbol Suggestions",
        type: "Type",
        category: "Category",
        emoji: "Emoji",
        symbol: "Symbol",
        predicted: "Predicted from your input",
        typo: "Suggested for possible typo",
        emoji_suggestion_cat: "Emoji Suggestion",
        symbol_suggestion_cat: "Symbol Suggestion",
        search_placeholder: "Search on FanTrove",
        search_result_here: "Search results will appear here"
    }
};
function t(key) {
    const lang = getLang();
    return (LANG_TEXTS[lang] && LANG_TEXTS[lang][key]) || (LANG_TEXTS["en"][key] || key);
}
function getLang() {
    return localStorage.getItem('selectedLang') || (navigator.language && navigator.language.startsWith('th') ? 'th' : 'en');
}

// เลือกชื่อจากอ็อบเจ็กต์ภาษา (multi-lang) ด้วยภาษาไหนก็ได้
function pickLang(obj, langList) {
    if (typeof obj !== 'object' || obj === null) return obj;
    for (const lang of langList) {
        if (obj[lang]) return obj[lang];
    }
    // fallback to first available
    const keys = Object.keys(obj);
    if (keys.length > 0) return obj[keys[0]];
    return '';
}

// สร้างลิสต์ภาษาทั้งหมดที่ระบบรองรับ (จากข้อมูล)
function getAllAvailableLangs(apiData) {
    const langs = new Set();
    if (!apiData || !Array.isArray(apiData.type)) return ['en'];
    apiData.type.forEach(typeObj => {
        if (typeof typeObj.name === 'object')
            Object.keys(typeObj.name).forEach(l => langs.add(l));
        (typeObj.category || []).forEach(cat => {
            if (typeof cat.name === 'object')
                Object.keys(cat.name).forEach(l => langs.add(l));
            (cat.data || []).forEach(item => {
                if (typeof item.name === 'object')
                    Object.keys(item.name).forEach(l => langs.add(l));
                Object.entries(item).forEach(([k, v]) => {
                    if (/_name$/.test(k) && typeof v === 'object') {
                        Object.keys(v).forEach(l => langs.add(l));
                    }
                });
            });
        });
    });
    return Array.from(langs);
}

// ดึงคีย์เวิร์ดและชื่อทุกภาษาเพื่อให้ค้นหาได้ทุกภาษา
function generateAllKeywords(apiData) {
    const keywordMap = new Map();
    const langs = getAllAvailableLangs(apiData);
    if (!apiData || !Array.isArray(apiData.type)) return [];
    apiData.type.forEach(typeObj => {
        langs.forEach(lang => {
            const typeName = pickLang(typeObj.name, [lang]);
            if (typeName) {
                keywordMap.set(`type|${lang}|${typeName.toLowerCase()}`, {
                    typeObj, typeName, lang, key: typeName.toLowerCase(), isType: true
                });
            }
        });

        (typeObj.category || []).forEach(cat => {
            langs.forEach(lang => {
                const catName = pickLang(cat.name, [lang]);
                if (catName) {
                    keywordMap.set(`category|${lang}|${catName.toLowerCase()}`, {
                        typeObj, category: cat, typeName: pickLang(typeObj.name, [lang]), catName, lang, key: catName.toLowerCase(), isCategory: true
                    });
                }
            });
            (cat.data || []).forEach(item => {
                langs.forEach(lang => {
                    const itemName = pickLang(item.name, [lang]);
                    if (itemName) {
                        keywordMap.set(`item|${lang}|${itemName.toLowerCase()}`, {
                            typeObj, category: cat, item, typeName: pickLang(typeObj.name, [lang]), catName: pickLang(cat.name, [lang]), itemName, lang, key: itemName.toLowerCase(), isCategory: false
                        });
                    }
                });
                Object.entries(item).forEach(([k, v]) => {
                    if (/_name$/.test(k) && v) {
                        langs.forEach(lang => {
                            const vVal = pickLang(v, [lang]);
                            if (vVal) {
                                keywordMap.set(`item|${lang}|${vVal.toLowerCase()}`, {
                                    typeObj, category: cat, item, typeName: pickLang(typeObj.name, [lang]), catName: pickLang(cat.name, [lang]), itemName: vVal, lang, key: vVal.toLowerCase(), isCategory: false
                                });
                            }
                        });
                    }
                });
                if (item.text) {
                    keywordMap.set(`item|text|${item.text.toLowerCase()}`, {
                        typeObj, category: cat, item, typeName: pickLang(typeObj.name, langs), catName: pickLang(cat.name, langs), itemName: pickLang(item.name, langs), lang: 'text', key: item.text.toLowerCase(), isCategory: false
                    });
                }
                if (item.api) {
                    keywordMap.set(`item|api|${item.api.toLowerCase()}`, {
                        typeObj, category: cat, item, typeName: pickLang(typeObj.name, langs), catName: pickLang(cat.name, langs), itemName: pickLang(item.name, langs), lang: 'api', key: item.api.toLowerCase(), isCategory: false
                    });
                }
            });
        });
    });
    return Array.from(keywordMap.values());
}

function levenshtein(a, b) {
    if (a === b) return 0;
    if (!a) return b.length;
    if (!b) return a.length;
    const matrix = [];
    for (let i = 0; i <= b.length; i++) matrix[i] = [i];
    for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
    for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
            matrix[i][j] = b.charAt(i - 1) === a.charAt(j - 1)
                ? matrix[i - 1][j - 1]
                : Math.min(
                    matrix[i - 1][j - 1] + 1,
                    matrix[i][j - 1] + 1,
                    matrix[i - 1][j] + 1
                );
        }
    }
    return matrix[b.length][a.length];
}

function computeRelevanceScore(query, target, baseScore = 100) {
    if (!target) return baseScore;
    let minScore = levenshtein(query, target);
    if (target.startsWith(query)) minScore -= 1;
    if (target.includes(query)) minScore -= 0.5;
    return minScore;
}

function keywordExactSubstringMatch(query, allKeywords) {
    query = query.toLowerCase();
    return allKeywords.some(k => k.key.includes(query));
}

function getBestKeywordMatches(query, allKeywords, maxCount = 12, allowGuess = true) {
    if (!query) return [];
    if (!allowGuess && keywordExactSubstringMatch(query, allKeywords)) {
        return [];
    }
    let scored = allKeywords.map(k => {
        let scores = [];
        scores.push(computeRelevanceScore(query, k.key, 100));
        if (k.isCategory && k.catName)
            scores.push(computeRelevanceScore(query, k.catName, 110));
        if (k.typeName)
            scores.push(computeRelevanceScore(query, k.typeName, 110));
        if (k.itemName)
            scores.push(computeRelevanceScore(query, k.itemName, 120));
        if (k.item) {
            if (k.item.text) scores.push(computeRelevanceScore(query, k.item.text, 120));
            if (k.item.api) scores.push(computeRelevanceScore(query, k.item.api, 125));
        }
        let minScore = Math.min(...scores);
        return { k, score: minScore };
    });
    scored.sort((a, b) => a.score - b.score);
    const best = scored.filter(s => s.score <= 2);
    const seen = new Set();
    const uniqueBest = [];
    for (const { k, score } of best) {
        const uniqKey = k.isType
            ? `type|${k.typeName}|${k.lang}`
            : k.isCategory
                ? `cat|${k.typeName}|${k.catName}|${k.lang}`
                : `item|${k.typeName}|${k.catName}|${k.item.api || k.item.text || ''}|${k.lang}`;
        if (!seen.has(uniqKey)) {
            uniqueBest.push({ ...k, fuzzyScore: score });
            seen.add(uniqKey);
        }
        if (uniqueBest.length >= maxCount) break;
    }
    return uniqueBest;
}

function setupTypeFilter(selected = 'all') {
    const typeFilter = document.getElementById('typeFilter');
    typeFilter.innerHTML = '';
    const optionAll = document.createElement('option');
    optionAll.value = 'all';
    optionAll.textContent = t('all_types');
    typeFilter.appendChild(optionAll);

    if (!apiData || !Array.isArray(apiData.type)) return;
    const lang = getLang();
    apiData.type.forEach(typeObj => {
        let label = pickLang(typeObj.name, [lang]);
        const opt = document.createElement('option');
        opt.value = label;
        opt.textContent = label;
        typeFilter.appendChild(opt);
    });
    typeFilter.value = selected;
}

function setupCategoryFilter(categories, selected = 'all') {
    const catFilter = document.getElementById('categoryFilter');
    catFilter.innerHTML = '';
    catFilter.style.display = '';
    const optAll = document.createElement('option');
    optAll.value = 'all';
    optAll.textContent = t('all_categories');
    catFilter.appendChild(optAll);
    categories.forEach(({ key, displayName }) => {
        const opt = document.createElement('option');
        opt.value = key;
        opt.textContent = displayName;
        catFilter.appendChild(opt);
    });
    catFilter.value = selected;
}

function getRandomSuggestions(arr, count = 5) {
    if (!arr || !arr.length) return [];
    const shuffled = arr.slice().sort(() => 0.5 - Math.random());
    return shuffled.slice(0, Math.min(count, arr.length));
}

// ระบบค้นหาหลายภาษาและฉลาดขึ้น
function smartSearch(apiData, query, typeFilter, allKeywords) {
    query = (query || '').toLowerCase().trim();
    if (!query) return [];
    let results = [];
    const langs = getAllAvailableLangs(apiData);

    if (!apiData || !Array.isArray(apiData.type)) return results;
    // ค้นหาทุกภาษา
    apiData.type.forEach(typeObj => {
        langs.forEach(lang => {
            let typeLabel = pickLang(typeObj.name, [lang]);
            if (typeFilter !== 'all' && pickLang(typeObj.name, [getLang()]) !== typeFilter) return;
            (typeObj.category || []).forEach(cat => {
                let catName = pickLang(cat.name, [lang]);
                const catNames = [catName.toLowerCase()];
                (cat.data || []).forEach(item => {
                    let itemNames = [];
                    if (item.name) itemNames = [pickLang(item.name, [lang]).toLowerCase()];
                    Object.entries(item).forEach(([k, v]) => {
                        if (/_name$/.test(k) && v) {
                            itemNames.push(pickLang(v, [lang]).toLowerCase());
                        }
                    });
                    const matchTokens = [ ...catNames, ...itemNames, (item.text||''), (item.api||'') ];
                    let isMatch = matchTokens.some(txt => txt && txt.includes(query));
                    let minFuzz = Math.min(...matchTokens.map(txt => txt ? levenshtein(query, txt) : 100));
                    let isFuzzy = !isMatch && minFuzz <= 2;
                    if (isMatch || isFuzzy) {
                        results.push({
                            typeObj,
                            typeName: typeLabel,
                            category: cat,
                            catName,
                            item,
                            itemName: pickLang(item.name, [lang]),
                            lang,
                            fuzzy: !isMatch && isFuzzy,
                            fuzzyScore: minFuzz
                        });
                    }
                });
            });
        });
    });

    // 1. Case: query is substring of any keyword in any language (don't guess, don't show prediction)
    if (keywordExactSubstringMatch(query, allKeywords)) {
        results = results.filter(r => !r.fuzzy);
        if (results.length === 0) return [];
        return results;
    }

    // 2. Case: allow prediction across all languages (ฉลาดขึ้น)
    if (results.length > 0) {
        const allFuzzy = results.every(r => r.fuzzy);
        if (allFuzzy) results = results.map(r => ({ ...r, isPrediction: true }));
        return results;
    }

    // 3. If no results, try prediction levenshtein <= 2, across all language keywords
    const predictionResults = getBestKeywordMatches(query, allKeywords, 10, false);
    if (predictionResults.length === 0) return [];
    return predictionResults.map(s => {
        if (s.isType) {
            return {
                typeObj: s.typeObj,
                typeName: s.typeName,
                category: (s.typeObj.category && s.typeObj.category[0]) || { name: "", data: [] },
                catName: pickLang((s.typeObj.category && s.typeObj.category[0] && s.typeObj.category[0].name) || "", [s.lang]),
                item: (((s.typeObj.category || [])[0]||{}).data||[{}])[0] || { text: '', api: '' },
                itemName: "",
                lang: s.lang,
                isSuggestion: true,
                isPrediction: true,
                suggestionType: 'type',
                suggestionKeyword: s.key,
                fuzzyScore: s.fuzzyScore
            };
        } else if (s.isCategory) {
            return {
                typeObj: s.typeObj,
                typeName: s.typeName,
                category: s.category,
                catName: s.catName,
                item: ((s.category.data && s.category.data.length) ? s.category.data[0] : { text: '', api: '' }),
                itemName: "",
                lang: s.lang,
                isSuggestion: true,
                isPrediction: true,
                suggestionType: 'category',
                suggestionKeyword: s.key,
                fuzzyScore: s.fuzzyScore
            };
        } else {
            return {
                typeObj: s.typeObj,
                typeName: s.typeName,
                category: s.category,
                catName: s.catName,
                item: s.item,
                itemName: s.itemName,
                lang: s.lang,
                isSuggestion: true,
                isPrediction: true,
                suggestionType: 'item',
                suggestionKeyword: s.key,
                fuzzyScore: s.fuzzyScore
            };
        }
    });
}

function extractResultCategories(results) {
    const lang = getLang();
    const categories = [];
    const seen = new Set();
    results.forEach(res => {
        const cat = res.category;
        let key = pickLang(cat.name, [lang]);
        const displayName = key;
        if (!seen.has(key)) {
            seen.add(key);
            categories.push({ key, displayName });
        }
    });
    return categories;
}

function showCopyToast(msg) {
    const toast = document.createElement('div');
    toast.className = 'copy-toast-message';
    toast.textContent = msg;
    document.getElementById('copyToast').appendChild(toast);
    setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateY(-10px)';
        setTimeout(() => toast.remove(), 250);
    }, 1400);
}

async function copyText(text) {
    try {
        await navigator.clipboard.writeText(text);
        showCopyToast(t('copy') + 'แล้ว');
    } catch {
        showCopyToast('ไม่สามารถ' + t('copy') + 'ได้');
    }
}

function renderSuggestionsBlock(lang, emojis = [], symbols = []) {
    let html = '';
    if (emojis.length) {
        html += `<div class="suggestions-head">${t('emoji_suggestions')}</div>`;
        html += emojis.map(obj => renderSuggestionItemWithRealCategory(obj, lang)).join('');
    }
    if (symbols.length) {
        html += `<div class="suggestions-head">${t('symbol_suggestions')}</div>`;
        html += symbols.map(obj => renderSuggestionItemWithRealCategory(obj, lang)).join('');
    }
    return `<div class="suggestions-block-list">${html}</div>`;
}

function renderSuggestionItemWithRealCategory(obj, lang) {
    const typeLabel = t('type');
    const catLabel = t('category');
    let catName = obj.category
        ? pickLang(obj.category.name, [lang]) || obj.category.name || ""
        : '';
    let typeDisplay = obj.typeObj
        ? pickLang(obj.typeObj.name, [lang]) || obj.typeObj.name || ""
        : '';
    if (!typeDisplay) typeDisplay = t('emoji');

    return `
    <div class="result-item">
        <div class="result-content-area">
            <div class="result-text-area">
                <span class="result-text">${obj.text || '-'}</span>
                <span class="result-api">${obj.api || ''}</span>
            </div>
            <div class="result-names"></div>
            <div class="result-meta" style="margin-top:13px;">
                <div>
                    <span class="result-meta-label">${typeLabel}:</span>
                    <span class="result-meta-value">${typeDisplay}</span>
                </div>
                <div>
                    <span class="result-meta-label">${catLabel}:</span>
                    <span class="result-meta-value">${catName}</span>
                </div>
            </div>
        </div>
        <button class="result-copy-btn" onclick="window._copyResultText('${encodeURIComponent(obj.text || '')}', event)" title="${t('copy')}">${t('copy')} <span class="copy-icon">📋</span></button>
    </div>
    `;
}

function renderResults(results, showSuggestionsIfNoResult = false) {
    const container = document.getElementById('searchResults');
    container.innerHTML = '';
    const lang = getLang();

    let filtered = results;
    if (selectedCategory !== 'all') {
        filtered = results.filter(res => {
            let key = pickLang(res.category.name, [lang]);
            return key === selectedCategory;
        });
    }

    if (!filtered.length) {
        let html = `<div class="no-result">${t('not_found')}</div>`;
        if (showSuggestionsIfNoResult) {
            html += `<div class="suggestions-title-main">${t('suggestions_for_you')}</div>`;
            html += renderSuggestionsBlock(
                lang,
                getRandomSuggestions(emojiSuggestionsCache, 4),
                getRandomSuggestions(symbolSuggestionsCache, 4)
            );
        }
        container.innerHTML = html;
        document.getElementById('categoryFilter').style.display = '';
        filterCategories = [];
        updateUILanguage();
        return;
    }

    container.innerHTML = filtered.map((res, idx) => {
        let itemNames = [];
        if (res.item.name) itemNames = [pickLang(res.item.name, [lang])];
        Object.entries(res.item).forEach(([k, v]) => {
            if (/_name$/.test(k) && v) {
                itemNames.push(pickLang(v, [lang]));
            }
        });
        itemNames = itemNames.filter(Boolean).join(' / ');

        const typeLabel = t('type');
        const catLabel = t('category');
        let typeDisplay = res.typeObj && res.typeObj.name ? pickLang(res.typeObj.name, [lang]) : "";
        if (!typeDisplay) typeDisplay = t('emoji');
        const catDisplay = pickLang(res.category.name, [lang]) || res.category.name;
        const copyBtnHtml = `<button class="result-copy-btn" onclick="window._copyResultText('${encodeURIComponent(res.item.text)}', event)" title="${t('copy')}">${t('copy')} <span class="copy-icon">📋</span></button>`;
        let fuzzyHint = '';
        if (res.fuzzy && res.isPrediction) fuzzyHint = `<div class="fuzzy-hint" style="color:#e08b35;font-size:.98em;font-weight:400; margin-bottom:4px;">${t('predicted')}</div>`;
        return `
        <div class="result-item">
            <div class="result-content-area">
                ${fuzzyHint}
                <div class="result-text-area">
                    <span class="result-text">${res.item.text || '-'}</span>
                    <span class="result-api">${res.item.api || ''}</span>
                </div>
                <div class="result-names">${itemNames}</div>
                <div class="result-meta" style="margin-top:13px;">
                    <div>
                        <span class="result-meta-label">${typeLabel}:</span>
                        <span class="result-meta-value">${typeDisplay}</span>
                    </div>
                    <div>
                        <span class="result-meta-label">${catLabel}:</span>
                        <span class="result-meta-value">${catDisplay}</span>
                    </div>
                </div>
            </div>
            ${copyBtnHtml}
        </div>
        `;
    }).join('');
    window._copyResultText = function(text, ev) {
        ev.preventDefault();
        copyText(decodeURIComponent(text));
    };
    updateUILanguage();
}

function prepareSuggestionCaches(apiData) {
    emojiSuggestionsCache = [];
    symbolSuggestionsCache = [];
    if (!apiData || !Array.isArray(apiData.type)) return;
    const langs = getAllAvailableLangs(apiData);
    apiData.type.forEach(typeObj => {
        const typeEn = pickLang(typeObj.name, ["en"]).toLowerCase();
        typeObj.category.forEach(cat => {
            (cat.data || []).forEach(item => {
                if (typeEn === "emoji") {
                    emojiSuggestionsCache.push({
                        text: item.text,
                        api: item.api,
                        category: cat,
                        typeObj
                    });
                } else if (typeEn === "symbol") {
                    symbolSuggestionsCache.push({
                        text: item.text,
                        api: item.api,
                        category: cat,
                        typeObj
                    });
                }
            });
        });
    });
}

function closeMobileKeyboard() {
    const input = document.getElementById('searchInput');
    if (input && document.activeElement === input) {
        input.blur();
    }
}

function doSearch(e) {
    if (e) e.preventDefault();
    const q = document.getElementById('searchInput').value;
    selectedType = document.getElementById('typeFilter').value;
    selectedCategory = 'all';
    if (!q.trim()) {
        document.getElementById('searchResults').innerHTML = `<div class="search-result-here" style="text-align:center;color:#969ca8;font-size:1.07em;margin-top:30px;">${t('search_result_here')}</div>`;
        setupCategoryFilter([], 'all');
        filterCategories = [];
        updateUILanguage();
        return;
    }
    currentResults = smartSearch(apiData, q, selectedType, allKeywordsCache);

    filterCategories = extractResultCategories(currentResults);
    setupCategoryFilter(filterCategories, 'all');
    renderResults(currentResults, currentResults.length === 0);
    updateUILanguage();
}

function onTypeChange() {
    selectedType = document.getElementById('typeFilter').value;
    doSearch();
}

function onCategoryChange() {
    selectedCategory = document.getElementById('categoryFilter').value;
    renderResults(currentResults, false);
    updateUILanguage();
}

function setupMobileSelectEnter() {
    ['typeFilter', 'categoryFilter'].forEach(id => {
        const el = document.getElementById(id);
        el.addEventListener('change', () => {
            if (id === 'typeFilter') onTypeChange();
            else onCategoryChange();
        });
        el.addEventListener('keyup', function(e) {
            if (e.key === 'Enter') {
                if (id === 'typeFilter') onTypeChange();
                else onCategoryChange();
            }
        });
    });
}

function setupAutoSearchInput() {
    const input = document.getElementById('searchInput');
    input.setAttribute('enterkeyhint', 'search');
    input.addEventListener('input', function() {
        clearTimeout(debounceTimeout);
        debounceTimeout = setTimeout(() => doSearch(), 160);
    });
    input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            doSearch();
            closeMobileKeyboard();
        }
    });
}

window.setUILanguage = function(lang) {
    localStorage.setItem('selectedLang', lang);
    updateUILanguage();
    setupTypeFilter(selectedType);
    setupCategoryFilter(filterCategories, selectedCategory);
    renderResults(currentResults, currentResults && currentResults.length === 0);
};

fetch('/assets/json/api-database.min.json')
    .then(res => res.json())
    .then(data => {
        apiData = data;
        allKeywordsCache = generateAllKeywords(apiData);
        prepareSuggestionCaches(apiData);
        setupTypeFilter('all');
        setupMobileSelectEnter();
        setupAutoSearchInput();
        setupCategoryFilter([], 'all');
        document.getElementById('searchResults').innerHTML = `<div class="search-result-here" style="text-align:center;color:#969ca8;font-size:1.07em;margin-top:30px;">${t('search_result_here')}</div>`;
        updateUILanguage();
    });

document.getElementById('searchForm').addEventListener('submit', e => { 
    e.preventDefault();
    doSearch();
    closeMobileKeyboard();
});
document.getElementById('searchInput').addEventListener('keydown', function(e){
    if(e.key === 'Enter') {
        e.preventDefault();
        doSearch();
        closeMobileKeyboard();
    }
});