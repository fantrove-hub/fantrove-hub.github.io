// Ultra fast, high-accuracy search engine with improved single-character detection logic and dynamic margin for body

let apiData = null;
let currentResults = [];
let filterCategories = [];
let selectedType = 'all';
let selectedCategory = 'all';
let debounceTimeout = null;
let allKeywordsCache = [];
let emojiSuggestionsCache = [];
let symbolSuggestionsCache = [];

// --- Localization ---
const LANG_TEXTS = {
    th: { all_types: "ทุกประเภท", all_categories: "ทุกหมวดหมู่", not_found: "ไม่พบข้อมูลที่ตรงหรือใกล้เคียงกับคำค้นของคุณ", copy: "คัดลอก", suggestions_for_you: "แนะนำสำหรับคุณ", emoji_suggestions: "แนะนำอีโมจิ", symbol_suggestions: "แนะนำสัญลักษณ์พิเศษ", type: "ประเภท", category: "หมวดหมู่", emoji: "อีโมจิ", symbol: "สัญลักษณ์", predicted: "คาดคะเนจากคำค้น", typo: "แนะนำจากคำที่อาจสะกดผิด", emoji_suggestion_cat: "แนะนำอีโมจิ", symbol_suggestion_cat: "แนะนำสัญลักษณ์", search_placeholder: "ค้นหาบน FanTrove", search_result_here: "ผลการค้นหาจะแสดงที่นี่" },
    en: { all_types: "All Types", all_categories: "All Categories", not_found: "No data found related to your keyword.", copy: "Copy", suggestions_for_you: "Suggestions For You", emoji_suggestions: "Emoji Suggestions", symbol_suggestions: "Special Symbol Suggestions", type: "Type", category: "Category", emoji: "Emoji", symbol: "Symbol", predicted: "Predicted from your input", typo: "Suggested for possible typo", emoji_suggestion_cat: "Emoji Suggestion", symbol_suggestion_cat: "Symbol Suggestion", search_placeholder: "Search on FanTrove", search_result_here: "Search results will appear here" }
};
const t = (k) => { const l = getLang(); return (LANG_TEXTS[l] && LANG_TEXTS[l][k]) || LANG_TEXTS.en[k] || k; };
const getLang = () => localStorage.getItem('selectedLang') || (navigator.language && navigator.language.startsWith('th') ? 'th' : 'en');
const pickLang = (obj, langs) => {
    if (!obj || typeof obj !== 'object') return obj;
    for (let i = 0; i < langs.length; ++i) if (obj[langs[i]]) return obj[langs[i]];
    for (const k in obj) return obj[k];
    return '';
};

// --- Performance: direct array ops, less allocations ---
function getAllAvailableLangs(apiData) {
    const langs = Object.create(null);
    if (!apiData || !Array.isArray(apiData.type)) return ['en'];
    for (let i = 0, T = apiData.type.length; i < T; ++i) {
        const typeObj = apiData.type[i];
        if (typeof typeObj.name === 'object') for (const k in typeObj.name) langs[k] = 1;
        const categories = typeObj.category || [];
        for (let j = 0, C = categories.length; j < C; ++j) {
            const cat = categories[j];
            if (typeof cat.name === 'object') for (const k in cat.name) langs[k] = 1;
            const items = cat.data || [];
            for (let x = 0, N = items.length; x < N; ++x) {
                const item = items[x];
                if (typeof item.name === 'object') for (const k in item.name) langs[k] = 1;
                for (const k in item) if (/_name$/.test(k) && typeof item[k] === 'object')
                    for (const l in item[k]) langs[l] = 1;
            }
        }
    }
    return Object.keys(langs);
}

function generateAllKeywords(apiData) {
    const arr = [];
    const langs = getAllAvailableLangs(apiData);
    if (!apiData || !Array.isArray(apiData.type)) return [];
    for (let i = 0, T = apiData.type.length; i < T; ++i) {
        const typeObj = apiData.type[i];
        for (let l = 0, L = langs.length; l < L; ++l) {
            const lang = langs[l];
            const typeName = pickLang(typeObj.name, [lang]);
            if (typeName) arr.push({ typeObj, typeName, lang, key: typeName.toLowerCase(), isType: true });
        }
        const categories = typeObj.category || [];
        for (let j = 0, C = categories.length; j < C; ++j) {
            const cat = categories[j];
            for (let l = 0, L = langs.length; l < L; ++l) {
                const lang = langs[l];
                const catName = pickLang(cat.name, [lang]);
                if (catName) arr.push({ typeObj, category: cat, typeName: pickLang(typeObj.name, [lang]), catName, lang, key: catName.toLowerCase(), isCategory: true });
            }
            const items = cat.data || [];
            for (let x = 0, N = items.length; x < N; ++x) {
                const item = items[x];
                for (let l = 0, L = langs.length; l < L; ++l) {
                    const lang = langs[l];
                    const itemName = pickLang(item.name, [lang]);
                    if (itemName) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name, [lang]), catName: pickLang(cat.name, [lang]), itemName, lang, key: itemName.toLowerCase(), isCategory: false });
                }
                for (const k in item) {
                    if (/_name$/.test(k) && typeof item[k] === 'object') {
                        for (let l = 0, L = langs.length; l < L; ++l) {
                            const lang = langs[l];
                            const vVal = pickLang(item[k], [lang]);
                            if (vVal) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name, [lang]), catName: pickLang(cat.name, [lang]), itemName: vVal, lang, key: vVal.toLowerCase(), isCategory: false });
                        }
                    }
                }
                if (item.text) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name, langs), catName: pickLang(cat.name, langs), itemName: pickLang(item.name, langs), lang: 'text', key: item.text.toLowerCase(), isCategory: false });
                if (item.api) arr.push({ typeObj, category: cat, item, typeName: pickLang(typeObj.name, langs), catName: pickLang(cat.name, langs), itemName: pickLang(item.name, langs), lang: 'api', key: item.api.toLowerCase(), isCategory: false });
            }
        }
    }
    return arr;
}

function levenshtein(a, b) {
    if (a === b) return 0;
    const al = a.length, bl = b.length;
    if (!al) return bl;
    if (!bl) return al;
    let v0 = new Uint16Array(bl + 1), v1 = new Uint16Array(bl + 1);
    for (let i = 0; i <= bl; ++i) v0[i] = i;
    for (let i = 0; i < al; ++i) {
        v1[0] = i + 1;
        for (let j = 0; j < bl; ++j)
            v1[j + 1] = Math.min(
                v1[j] + 1,
                v0[j + 1] + 1,
                v0[j] + (a[i] === b[j] ? 0 : 1)
            );
        let t = v0; v0 = v1; v1 = t;
    }
    return v0[bl];
}
const computeRelevanceScore = (query, target, baseScore = 100) => (!target ? baseScore : (() => {
    let s = levenshtein(query, target);
    if (target.startsWith(query)) s -= 1;
    if (target.includes(query)) s -= 0.5;
    return s;
})());
const keywordExactSubstringMatch = (query, allKeywords) => {
    query = query.toLowerCase();
    for (let i = 0, L = allKeywords.length; i < L; ++i) if (allKeywords[i].key.includes(query)) return true;
    return false;
};

function getBestKeywordMatches(query, allKeywords, maxCount = 12, allowGuess = true) {
    if (!query) return [];
    if (!allowGuess && keywordExactSubstringMatch(query, allKeywords)) return [];
    let out = [];
    for (let i = 0, L = allKeywords.length; i < L; ++i) {
        const k = allKeywords[i];
        let s = [computeRelevanceScore(query, k.key, 100)];
        if (k.isCategory && k.catName) s.push(computeRelevanceScore(query, k.catName, 110));
        if (k.typeName) s.push(computeRelevanceScore(query, k.typeName, 110));
        if (k.itemName) s.push(computeRelevanceScore(query, k.itemName, 120));
        if (k.item) {
            if (k.item.text) s.push(computeRelevanceScore(query, k.item.text, 120));
            if (k.item.api) s.push(computeRelevanceScore(query, k.item.api, 125));
        }
        k._score = Math.min.apply(null, s);
        out.push(k);
    }
    out.sort((a, b) => a._score - b._score);
    let seen = new Set(), uniq = [], cnt = 0;
    for (let i = 0, L = out.length; i < L && cnt < maxCount; ++i) {
        const k = out[i];
        if (k._score > 2) break;
        const uniqKey = k.isType ? `type|${k.typeName}|${k.lang}` : k.isCategory
            ? `cat|${k.typeName}|${k.catName}|${k.lang}` : `item|${k.typeName}|${k.catName}|${k.item && (k.item.api || k.item.text) || ''}|${k.lang}`;
        if (!seen.has(uniqKey)) { seen.add(uniqKey); uniq.push(Object.assign({}, k, { fuzzyScore: k._score })); ++cnt; }
    }
    return uniq;
}

// -----------------------------------------
// ---- IMPROVED SEARCH LOGIC STARTS HERE ---
// -----------------------------------------
function smartSearch(apiData, query, typeFilter, allKeywords) {
    query = (query || '').toLowerCase().trim();
    if (!query) return [];
    let results = [], langs = getAllAvailableLangs(apiData);

    if (!apiData || !Array.isArray(apiData.type)) return results;

    // Precise handling for single-character input
    if (query.length === 1) {
        let has = false;
        for (let i = 0, L = allKeywords.length; i < L; ++i) {
            if (allKeywords[i].key.includes(query)) { has = true; break; }
        }
        if (!has) return [];
    }

    for (let i = 0, T = apiData.type.length; i < T; ++i) {
        const typeObj = apiData.type[i];
        for (let l = 0, L = langs.length; l < L; ++l) {
            const lang = langs[l];
            let typeLabel = pickLang(typeObj.name, [lang]);
            if (typeFilter !== 'all' && pickLang(typeObj.name, [getLang()]) !== typeFilter) continue;
            const cats = typeObj.category || [];
            for (let j = 0, C = cats.length; j < C; ++j) {
                let cat = cats[j], catName = pickLang(cat.name, [lang]);
                const catNames = [catName.toLowerCase()], items = cat.data || [];
                for (let x = 0, N = items.length; x < N; ++x) {
                    let item = items[x], itemNames = [];
                    if (item.name) itemNames.push(pickLang(item.name, [lang]).toLowerCase());
                    for (const k in item) if (/_name$/.test(k) && item[k]) itemNames.push(pickLang(item[k], [lang]).toLowerCase());
                    const matchTokens = catNames.concat(itemNames, (item.text || ''), (item.api || ''));
                    let isMatch = false, minFuzz = 100;
                    for (let y = 0, Y = matchTokens.length; y < Y; ++y) {
                        const txt = matchTokens[y];
                        if (!txt) continue;
                        if (txt.includes(query)) isMatch = true;
                        minFuzz = Math.min(minFuzz, levenshtein(query, txt));
                    }
                    let isFuzzy = !isMatch && minFuzz <= 2;
                    if (isMatch || isFuzzy) results.push({
                        typeObj, typeName: typeLabel, category: cat, catName, item,
                        itemName: pickLang(item.name, [lang]), lang, fuzzy: !isMatch && isFuzzy, fuzzyScore: minFuzz
                    });
                }
            }
        }
    }

    // If any exact substring match, show only those (never fuzzy/predict)
    if (keywordExactSubstringMatch(query, allKeywords)) {
        let sub = [];
        for (let i = 0, L = results.length; i < L; ++i) if (!results[i].fuzzy) sub.push(results[i]);
        return sub.length ? sub : [];
    }

    // For query length 1: if not found above, no prediction is allowed, return []
    if (query.length === 1) return [];

    // For length >= 2: Prediction as before
    if (results.length) {
        let allFuzzy = true;
        for (let i = 0, L = results.length; i < L; ++i) if (!results[i].fuzzy) { allFuzzy = false; break; }
        if (allFuzzy) for (let i = 0, L = results.length; i < L; ++i) results[i].isPrediction = true;
        return results;
    }
    const predictionResults = getBestKeywordMatches(query, allKeywords, 10, false);
    if (!predictionResults.length) return [];
    let out = [];
    for (let i = 0, L = predictionResults.length; i < L; ++i) {
        const s = predictionResults[i];
        if (s.isType) out.push({
            typeObj: s.typeObj, typeName: s.typeName,
            category: (s.typeObj.category && s.typeObj.category[0]) || { name: "", data: [] },
            catName: pickLang((s.typeObj.category && s.typeObj.category[0] && s.typeObj.category[0].name) || "", [s.lang]),
            item: (((s.typeObj.category || [])[0] || {}).data || [{}])[0] || { text: '', api: '' },
            itemName: "", lang: s.lang, isSuggestion: true, isPrediction: true, suggestionType: 'type', suggestionKeyword: s.key, fuzzyScore: s.fuzzyScore
        });
        else if (s.isCategory) out.push({
            typeObj: s.typeObj, typeName: s.typeName, category: s.category, catName: s.catName,
            item: ((s.category.data && s.category.data.length) ? s.category.data[0] : { text: '', api: '' }),
            itemName: "", lang: s.lang, isSuggestion: true, isPrediction: true, suggestionType: 'category', suggestionKeyword: s.key, fuzzyScore: s.fuzzyScore
        });
        else out.push({
            typeObj: s.typeObj, typeName: s.typeName, category: s.category, catName: s.catName, item: s.item, itemName: s.itemName,
            lang: s.lang, isSuggestion: true, isPrediction: true, suggestionType: 'item', suggestionKeyword: s.key, fuzzyScore: s.fuzzyScore
        });
    }
    return out;
}
// ---------------------------------------
// ---- END IMPROVED SEARCH LOGIC --------
// ---------------------------------------

function setupTypeFilter(selected = 'all') {
    const typeFilter = document.getElementById('typeFilter');
    let buf = [`<option value="all">${t('all_types')}</option>`];
    if (apiData && Array.isArray(apiData.type)) {
        const lang = getLang();
        for (let i = 0, T = apiData.type.length; i < T; ++i) {
            let label = pickLang(apiData.type[i].name, [lang]);
            buf.push(`<option value="${label}">${label}</option>`);
        }
    }
    typeFilter.innerHTML = buf.join('');
    typeFilter.value = selected;
}

function setupCategoryFilter(categories, selected = 'all') {
    const catFilter = document.getElementById('categoryFilter');
    let buf = [`<option value="all">${t('all_categories')}</option>`];
    for (let i = 0, L = categories.length; i < L; ++i) {
        const { key, displayName } = categories[i];
        buf.push(`<option value="${key}">${displayName}</option>`);
    }
    catFilter.innerHTML = buf.join('');
    catFilter.style.display = '';
    catFilter.value = selected;
}

function getRandomSuggestions(arr, count = 5) {
    if (!arr || !arr.length) return [];
    let n = arr.length, out = [], idx;
    for (let i = 0; i < count && n > 0; ++i, --n) {
        idx = (Math.random() * n) | 0;
        out.push(arr[idx]);
        arr[idx] = arr[n - 1];
    }
    return out;
}

function extractResultCategories(results) {
    const lang = getLang();
    let categories = [], seen = Object.create(null);
    for (let i = 0, L = results.length; i < L; ++i) {
        const cat = results[i].category, key = pickLang(cat.name, [lang]), displayName = key;
        if (!seen[key]) { seen[key] = 1; categories.push({ key, displayName }); }
    }
    return categories;
}

function showCopyToast(msg) {
    const toast = document.createElement('div');
    toast.className = 'copy-toast-message';
    toast.textContent = msg;
    document.getElementById('copyToast').appendChild(toast);
    setTimeout(() => { toast.style.opacity = '0'; toast.style.transform = 'translateY(-10px)'; setTimeout(() => toast.remove(), 250); }, 1400);
}

async function copyText(text) {
    try { await navigator.clipboard.writeText(text); showCopyToast(t('copy') + 'แล้ว'); }
    catch { showCopyToast('ไม่สามารถ' + t('copy') + 'ได้'); }
}

function renderSuggestionsBlock(lang, emojis = [], symbols = []) {
    let html = '';
    if (emojis.length) {
        html += `<div class="suggestions-head">${t('emoji_suggestions')}</div>`;
        for (let i = 0, L = emojis.length; i < L; ++i) html += renderSuggestionItemWithRealCategory(emojis[i], lang);
    }
    if (symbols.length) {
        html += `<div class="suggestions-head">${t('symbol_suggestions')}</div>`;
        for (let i = 0, L = symbols.length; i < L; ++i) html += renderSuggestionItemWithRealCategory(symbols[i], lang);
    }
    return `<div class="suggestions-block-list">${html}</div>`;
}
function renderSuggestionItemWithRealCategory(obj, lang) {
    const typeLabel = t('type'), catLabel = t('category');
    let catName = obj.category ? pickLang(obj.category.name, [lang]) || obj.category.name || "" : '';
    let typeDisplay = obj.typeObj ? pickLang(obj.typeObj.name, [lang]) || obj.typeObj.name || "" : '';
    if (!typeDisplay) typeDisplay = t('emoji');
    return `<div class="result-item"><div class="result-content-area"><div class="result-text-area"><span class="result-text">${obj.text || '-'}</span><span class="result-api">${obj.api || ''}</span></div><div class="result-names"></div><div class="result-meta" style="margin-top:13px;"><div><span class="result-meta-label">${typeLabel}:</span><span class="result-meta-value">${typeDisplay}</span></div><div><span class="result-meta-label">${catLabel}:</span><span class="result-meta-value">${catName}</span></div></div></div><button class="result-copy-btn" data-text="${encodeURIComponent(obj.text || '')}" title="${t('copy')}">${t('copy')} <span class="copy-icon">📋</span></button></div>`;
}

// --- เพิ่มฟังก์ชันนี้สำหรับปรับ margin ของ body ---
function setBodyMarginForSearch(active) {
    // เพิ่ม margin-bottom: 60px เฉพาะตอนมีการค้นหา (มีผลลัพธ์แสดงทั้งพบ/ไม่พบ)
    const body = document.body;
    if (active) {
        if (body.style.marginBottom !== "60px") body.style.marginBottom = "60px";
    } else {
        if (body.style.marginBottom !== "") body.style.marginBottom = "";
    }
}

function renderResults(results, showSuggestionsIfNoResult = false) {
    const container = document.getElementById('searchResults');
    const lang = getLang();
    let filtered = (selectedCategory !== 'all') ? results.filter(res => pickLang(res.category.name, [lang]) === selectedCategory) : results;
    let html = '';
    // --- ทุกครั้งที่แสดงผลค้นหา ไม่ว่าจะพบหรือไม่พบ ให้เพิ่ม margin-body ---
    setBodyMarginForSearch(true);
    if (!filtered.length) {
        html = `<div class="no-result">${t('not_found')}</div>`;
        if (showSuggestionsIfNoResult) {
            html += `<div class="suggestions-title-main">${t('suggestions_for_you')}</div>`;
            html += renderSuggestionsBlock(lang, getRandomSuggestions(emojiSuggestionsCache, 4), getRandomSuggestions(symbolSuggestionsCache, 4));
        }
        container.innerHTML = html;
        document.getElementById('categoryFilter').style.display = '';
        filterCategories = [];
        updateUILanguage();
        return;
    }
    let typeLabel = t('type'), catLabel = t('category');
    for (let i = 0, L = filtered.length; i < L; ++i) {
        const res = filtered[i];
        let itemNames = [];
        if (res.item.name) itemNames.push(pickLang(res.item.name, [lang]));
        for (const k in res.item) if (/_name$/.test(k) && res.item[k]) itemNames.push(pickLang(res.item[k], [lang]));
        itemNames = itemNames.filter(Boolean).join(' / ');
        let typeDisplay = res.typeObj && res.typeObj.name ? pickLang(res.typeObj.name, [lang]) : "";
        if (!typeDisplay) typeDisplay = t('emoji');
        const catDisplay = pickLang(res.category.name, [lang]) || res.category.name;
        let fuzzyHint = (res.fuzzy && res.isPrediction) ? `<div class="fuzzy-hint" style="color:#e08b35;font-size:.98em;font-weight:400; margin-bottom:4px;">${t('predicted')}</div>` : '';
        html += `<div class="result-item"><div class="result-content-area">${fuzzyHint}<div class="result-text-area"><span class="result-text">${res.item.text || '-'}</span><span class="result-api">${res.item.api || ''}</span></div><div class="result-names">${itemNames}</div><div class="result-meta" style="margin-top:13px;"><div><span class="result-meta-label">${typeLabel}:</span><span class="result-meta-value">${typeDisplay}</span></div><div><span class="result-meta-label">${catLabel}:</span><span class="result-meta-value">${catDisplay}</span></div></div></div><button class="result-copy-btn" data-text="${encodeURIComponent(res.item.text)}" title="${t('copy')}">${t('copy')} <span class="copy-icon">📋</span></button></div>`;
    }
    container.innerHTML = html;
    // Event delegation: only one event for all copy buttons
    if (!window._copyResultTextHandlerSet) {
        container.addEventListener('click', function(e) {
            const btn = e.target.closest('.result-copy-btn');
            if (btn && btn.hasAttribute('data-text')) {
                e.preventDefault(); copyText(decodeURIComponent(btn.getAttribute('data-text')));
            }
        });
        window._copyResultTextHandlerSet = true;
    }
    updateUILanguage();
}

function prepareSuggestionCaches(apiData) {
    emojiSuggestionsCache = []; symbolSuggestionsCache = [];
    if (!apiData || !Array.isArray(apiData.type)) return;
    const langs = getAllAvailableLangs(apiData);
    for (let i = 0, T = apiData.type.length; i < T; ++i) {
        const typeObj = apiData.type[i], typeEn = pickLang(typeObj.name, ["en"]).toLowerCase();
        for (let j = 0, C = typeObj.category.length; j < C; ++j) {
            const cat = typeObj.category[j], items = cat.data || [];
            for (let x = 0, N = items.length; x < N; ++x) {
                const item = items[x];
                if (typeEn === "emoji") emojiSuggestionsCache.push({ text: item.text, api: item.api, category: cat, typeObj });
                else if (typeEn === "symbol") symbolSuggestionsCache.push({ text: item.text, api: item.api, category: cat, typeObj });
            }
        }
    }
}

function closeMobileKeyboard() {
    const input = document.getElementById('searchInput');
    if (input && document.activeElement === input) input.blur();
}

function doSearch(e) {
    if (e) e.preventDefault();
    const q = document.getElementById('searchInput').value;
    selectedType = document.getElementById('typeFilter').value;
    selectedCategory = 'all';
    if (!q.trim()) {
        // --- ถ้าไม่มีการค้นหา ให้คืน margin-body กลับปกติ ---
        setBodyMarginForSearch(false);
        document.getElementById('searchResults').innerHTML = `<div class="search-result-here" style="text-align:center;color:#969ca8;font-size:1.07em;margin-top:30px;">${t('search_result_here')}</div>`;
        setupCategoryFilter([], 'all');
        filterCategories = [];
        updateUILanguage();
        return;
    }
    currentResults = smartSearch(apiData, q, selectedType, allKeywordsCache);
    filterCategories = extractResultCategories(currentResults);
    setupCategoryFilter(filterCategories, 'all');
    renderResults(currentResults, currentResults.length === 0);
    updateUILanguage();
}

function onTypeChange() { selectedType = document.getElementById('typeFilter').value; doSearch(); }
function onCategoryChange() { selectedCategory = document.getElementById('categoryFilter').value; renderResults(currentResults, false); updateUILanguage(); }

function setupMobileSelectEnter() {
    ['typeFilter', 'categoryFilter'].forEach(id => {
        const el = document.getElementById(id);
        el.onchange = () => (id === 'typeFilter' ? onTypeChange() : onCategoryChange());
        el.onkeyup = function(e) { if (e.key === 'Enter') (id === 'typeFilter' ? onTypeChange() : onCategoryChange()); };
    });
}
function setupAutoSearchInput() {
    const input = document.getElementById('searchInput');
    input.setAttribute('enterkeyhint', 'search');
    input.oninput = function() { clearTimeout(debounceTimeout); debounceTimeout = setTimeout(doSearch, 120); };
    input.onkeydown = function(e) { if (e.key === 'Enter') { e.preventDefault(); doSearch(); closeMobileKeyboard(); } };
}

function updateUILanguage() {
    const input = document.getElementById('searchInput');
    if (input && input.placeholder !== t('search_placeholder')) input.placeholder = t('search_placeholder');
    const filterGroupLabels = document.querySelectorAll('.search-filters-panel .filter-group-label');
    if (filterGroupLabels.length > 0 && filterGroupLabels[0].textContent !== t('type')) filterGroupLabels[0].textContent = t('type');
    if (filterGroupLabels.length > 1 && filterGroupLabels[1].textContent !== t('category')) filterGroupLabels[1].textContent = t('category');
}

window.setUILanguage = function(lang) {
    localStorage.setItem('selectedLang', lang);
    updateUILanguage();
    setupTypeFilter(selectedType);
    setupCategoryFilter(filterCategories, selectedCategory);
    renderResults(currentResults, currentResults && currentResults.length === 0);
};

fetch('/assets/json/api-database.min.json')
    .then(res => res.json())
    .then(data => {
        apiData = data;
        allKeywordsCache = generateAllKeywords(apiData);
        prepareSuggestionCaches(apiData);
        setupTypeFilter('all');
        setupMobileSelectEnter();
        setupAutoSearchInput();
        setupCategoryFilter([], 'all');
        setBodyMarginForSearch(false);
        document.getElementById('searchResults').innerHTML = `<div class="search-result-here" style="text-align:center;color:#969ca8;font-size:1.07em;margin-top:30px;">${t('search_result_here')}</div>`;
        updateUILanguage();
    });

document.getElementById('searchForm').addEventListener('submit', e => { e.preventDefault(); doSearch(); closeMobileKeyboard(); });
document.getElementById('searchInput').addEventListener('keydown', function(e){ if(e.key === 'Enter') { e.preventDefault(); doSearch(); closeMobileKeyboard(); } });