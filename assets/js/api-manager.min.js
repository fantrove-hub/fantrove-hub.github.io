document.addEventListener('DOMContentLoaded', function() {
    // --- Utility for new <-> old data conversion ---
    function newToOldFormat(newData) {
        // newData.type[] => oldData.emoji/symbol
        const oldData = {};
        (newData.type || []).forEach(typeObj => {
            // e.g. typeObj.name.en = 'Emoji' or 'Symbol'
            const typeKey = (typeObj.name && typeObj.name.en)
                ? typeObj.name.en.toLowerCase()
                : "";
            oldData[typeKey] = { category: [] };
            (typeObj.category || []).forEach(catObj => {
                oldData[typeKey].category.push({
                    name: catObj.name.en,
                    nameObj: catObj.name, // keep original full name for edit
                    data: (catObj.data || []).map(item => ({
                        api: item.api,
                        text: item.text,
                        nameObj: item.name // keep name object for edit
                    }))
                });
            });
        });
        return oldData;
    }
    function oldToNewFormat(oldData) {
        // oldData.emoji/symbol => newData.type[]
        const typeArr = [];
        Object.entries(oldData).forEach(([typeKey, typeVal]) => {
            // Try to find matching object, fallback to {th,en:typeKey}
            let typeName = { th: typeKey, en: typeKey.charAt(0).toUpperCase() + typeKey.slice(1) };
            // Use first category nameObj if available for better label (otherwise fallback to above)
            let firstCat = typeVal.category && typeVal.category[0];
            if (firstCat && firstCat.nameObj && firstCat.nameObj.en && typeVal.category.length > 0) {
                // try matching on known types
                if (typeKey === 'emoji') typeName = {th:"อีโมจิ",en:"Emoji"};
                if (typeKey === 'symbol') typeName = {th:"สัญลักษณ์",en:"Symbol"};
            }
            typeArr.push({
                name: typeName,
                category: (typeVal.category || []).map(cat => ({
                    name: cat.nameObj || { th: cat.name, en: cat.name },
                    data: (cat.data || []).map(item => ({
                        api: item.api,
                        text: item.text,
                        name: item.nameObj || { th: "", en: "" }
                    }))
                }))
            });
        });
        return { type: typeArr };
    }
    // -- End conversion utility --

    let apiData = null; // always in old format in memory!
    let isDarkMode = localStorage.getItem('darkMode') === 'true';
    let currentEditingItem = null;
    let categoryNameMap = {}; // Map typeKey=>[{en,th}...] for select option

    // DOM element references
    const searchInput = document.getElementById('searchInput');
    const filterType = document.getElementById('filterType');
    const filterCategory = document.getElementById('filterCategory');
    const dataContainer = document.getElementById('dataContainer');
    const modal = document.getElementById('detailModal');
    const modalContent = document.getElementById('modalContent');
    const closeModal = document.querySelector('.close');

    closeModal.onclick = () => modal.style.display = "none";
    window.onclick = (e) => {
        if (e.target === modal) modal.style.display = "none";
    }

    function updateTheme() {
        document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');
        document.getElementById('themeSwitcher').innerHTML =
            `<i class="fas fa-${isDarkMode ? 'sun' : 'moon'}"></i>`;
    }
    updateTheme();

    async function loadInitialData() {
        try {
            const response = await fetch('/assets/json/api-database.min.json');
            if (!response.ok) throw new Error('Network response was not ok');
            const loaded = await response.json();
            apiData = newToOldFormat(loaded);
            generateCategoryNameMap(loaded);
            updateUI();
            showToast('โหลดข้อมูลสำเร็จ', 'success');
        } catch (error) {
            console.error('ไม่สามารถโหลดข้อมูลได้:', error);
            showToast('ไม่สามารถโหลดข้อมูลได้', 'error');
            // fallback old structure (minimal)
            apiData = {
                emoji: { category: [] },
                symbol: { category: [] }
            };
        }
    }

    function generateCategoryNameMap(json) {
        // Structure: { emoji: [{en,th}], symbol: [{en,th}] }
        categoryNameMap = {};
        (json.type || []).forEach(typeObj => {
            const typeKey = typeObj.name && typeObj.name.en ? typeObj.name.en.toLowerCase() : "";
            categoryNameMap[typeKey] = [];
            (typeObj.category || []).forEach(cat => {
                if (cat.name && cat.name.en && cat.name.th) {
                    categoryNameMap[typeKey].push(cat.name);
                }
            });
        });
    }

    function updateUI() {
        updateCategorySelect();
        updateFilterCategories();
        updateStatistics();
        renderData();
    }

    function updateCategorySelect() {
        const mainType = document.getElementById('mainType').value;
        const categorySelect = document.getElementById('category');
        categorySelect.innerHTML = '';
        // Use categoryNameMap for better name, fallback to apiData
        let cats = (categoryNameMap[mainType] || []);
        if (cats.length === 0 && apiData[mainType]) {
            cats = (apiData[mainType].category || []).map(cat => ({en:cat.name, th:cat.name}));
        }
        cats.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat.en;
            option.textContent = cat.th + " / " + cat.en;
            categorySelect.appendChild(option);
        });
    }

    function updateFilterCategories() {
        const categories = new Set();
        Object.values(apiData).forEach(type => {
            if (type.category) {
                type.category.forEach(cat => categories.add(cat.name));
            }
        });
        filterCategory.innerHTML = '<option value="all">ทุกหมวดหมู่</option>';
        [...categories].sort().forEach(cat => {
            const option = document.createElement('option');
            option.value = cat;
            option.textContent = cat;
            filterCategory.appendChild(option);
        });
    }

    function updateStatistics() {
        let emojiCount = 0;
        let symbolCount = 0;
        let categoryCount = new Set();

        Object.entries(apiData).forEach(([type, data]) => {
            if (data.category) {
                data.category.forEach(cat => {
                    categoryCount.add(cat.name);
                    if (type === 'emoji') emojiCount += cat.data ? cat.data.length : 0;
                    else symbolCount += cat.data ? cat.data.length : 0;
                });
            }
        });
        document.getElementById('emojiCount').textContent = emojiCount;
        document.getElementById('symbolCount').textContent = symbolCount;
        document.getElementById('categoryCount').textContent = categoryCount.size;
    }

    // ------- CRUD & Render Logic (unchanged except for nameObj/name) --------
    window.editItem = function(type, category, index) {
        const categoryData = apiData[type].category.find(c => c.name === category);
        if (!categoryData || !categoryData.data) return;
        const item = categoryData.data[index];
        if (!item) return;
        currentEditingItem = { type, category, index };
        // Show modal with multi-language support
        modalContent.innerHTML = `
            <div class="edit-form">
                <div class="form-group">
                    <label>ข้อความ/สัญลักษณ์:</label>
                    <input type="text" id="editText" value="${item.text || ""}" class="form-control">
                </div>
                <div class="form-group">
                    <label>รหัส API:</label>
                    <input type="text" id="editApi" value="${item.api || ""}" class="form-control">
                </div>
                <div class="form-group">
                    <label>ชื่อ (TH):</label>
                    <input type="text" id="editNameTh" value="${(item.nameObj && item.nameObj.th) || ""}" class="form-control">
                </div>
                <div class="form-group">
                    <label>ชื่อ (EN):</label>
                    <input type="text" id="editNameEn" value="${(item.nameObj && item.nameObj.en) || ""}" class="form-control">
                </div>
                <div class="form-actions">
                    <button onclick="saveEdit()" class="btn btn-primary">
                        <i class="fas fa-save"></i> บันทึก
                    </button>
                    <button onclick="closeModal()" class="btn btn-secondary">
                        <i class="fas fa-times"></i> ยกเลิก
                    </button>
                </div>
            </div>
        `;
        modal.style.display = "block";
    };

    window.saveEdit = function() {
        if (!currentEditingItem) return;
        const newText = document.getElementById('editText').value.trim();
        const newApi = document.getElementById('editApi').value.trim();
        const nameTh = document.getElementById('editNameTh').value.trim();
        const nameEn = document.getElementById('editNameEn').value.trim();
        if (!validateInput(newText, newApi)) return;
        const { type, category, index } = currentEditingItem;
        const categoryData = apiData[type].category.find(c => c.name === category);
        if (categoryData && categoryData.data) {
            categoryData.data[index] = {
                text: newText,
                api: newApi,
                nameObj: { th: nameTh, en: nameEn }
            };
            updateUI();
            closeModal();
            showToast('แก้ไขข้อมูลสำเร็จ', 'success');
        }
    };

    window.deleteItem = function(type, category, index) {
        if (confirm('คุณแน่ใจหรือไม่ที่จะลบรายการนี้?')) {
            const categoryData = apiData[type].category.find(c => c.name === category);
            if (categoryData && categoryData.data) {
                categoryData.data.splice(index, 1);
                updateUI();
                showToast('ลบข้อมูลสำเร็จ', 'success');
            }
        }
    };

    window.closeModal = function() {
        modal.style.display = "none";
        currentEditingItem = null;
    };

    function renderData() {
        const searchTerm = searchInput.value.toLowerCase();
        const selectedType = filterType.value;
        const selectedCategory = filterCategory.value;
        dataContainer.innerHTML = '';
        Object.entries(apiData).forEach(([type, data]) => {
            if (selectedType !== 'all' && type !== selectedType) return;
            if (!data.category) return;
            const typeSection = document.createElement('div');
            typeSection.className = 'type-section';
            typeSection.innerHTML = `<h3>${type.toUpperCase()}</h3>`;
            data.category.forEach(category => {
                if (selectedCategory !== 'all' && category.name !== selectedCategory) return;
                if (!category.data) category.data = [];
                const filteredData = category.data.filter(item => {
                    return (item.text || "").toLowerCase().includes(searchTerm) ||
                           (item.api || "").toLowerCase().includes(searchTerm) ||
                           (item.nameObj && ((item.nameObj.th||"").toLowerCase().includes(searchTerm) || (item.nameObj.en||"").toLowerCase().includes(searchTerm)));
                });
                if (filteredData.length === 0) return;
                const categoryDiv = createCategorySection(type, category.name, filteredData);
                typeSection.appendChild(categoryDiv);
            });
            if (typeSection.children.length > 1) dataContainer.appendChild(typeSection);
        });
        setupDragAndDrop();
    }

    function createCategorySection(type, categoryName, items) {
        const div = document.createElement('div');
        div.className = 'data-group';
        div.innerHTML = `
            <div class="data-group-header">
                ${categoryName}
                <span class="item-count">(${items.length} รายการ)</span>
            </div>
            <div class="data-items" data-type="${type}" data-category="${categoryName}">
                ${items.map((item, index) => createDataItemHTML(type, categoryName, item, index)).join('')}
            </div>
        `;
        return div;
    }

    function createDataItemHTML(type, category, item, index) {
        // Show text/api/nameObj.th/en
        return `
            <div class="data-item" draggable="true" data-index="${index}">
                <div class="item-content">
                    <span class="item-text">${item.text}</span>
                    <span class="item-api">${item.api}</span>
                    <span class="item-name">${(item.nameObj && (item.nameObj.th || item.nameObj.en)) ? (item.nameObj.th + " / " + item.nameObj.en) : ""}</span>
                </div>
                <div class="item-actions">
                    <button onclick="editItem('${type}', '${category}', ${index})" class="btn-edit">
                        <i class="fas fa-edit"></i>
                    </button>
                    <button onclick="deleteItem('${type}', '${category}', ${index})" class="btn-delete">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
        `;
    }

    // --- Drag & Drop, Move, Add, Category, etc. (mostly unchanged) ---
    function setupDragAndDrop() {
        const items = document.querySelectorAll('.data-item');
        const containers = document.querySelectorAll('.data-items');
        items.forEach(item => {
            item.addEventListener('dragstart', handleDragStart);
            item.addEventListener('dragend', handleDragEnd);
            item.addEventListener('dragenter', handleDragEnter);
            item.addEventListener('dragleave', handleDragLeave);
        });
        containers.forEach(container => {
            container.addEventListener('dragover', handleDragOver);
            container.addEventListener('drop', handleDrop);
        });
    }
    function handleDragStart(e) {
        e.target.classList.add('dragging');
        e.target.style.opacity = '0.6';
        e.dataTransfer.effectAllowed = 'move';
        const container = e.target.closest('.data-items');
        e.dataTransfer.setData('text/plain', JSON.stringify({
            index: e.target.dataset.index,
            type: container.dataset.type,
            category: container.dataset.category
        }));
    }
    function handleDragEnter(e) {
        e.preventDefault();
        if (e.target.classList.contains('data-item') && !e.target.classList.contains('dragging')) {
            e.target.style.opacity = '0.4';
            e.target.classList.add('drop-target');
        }
    }
    function handleDragLeave(e) {
        e.preventDefault();
        if (e.target.classList.contains('data-item')) {
            e.target.style.opacity = '1';
            e.target.classList.remove('drop-target');
        }
    }
    function handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        const container = e.target.closest('.data-items');
        if (!container) return;
        const draggingItem = document.querySelector('.dragging');
        if (!draggingItem) return;
        const items = [...container.querySelectorAll('.data-item:not(.dragging)')];
        const afterElement = items.reduce((closest, item) => {
            const box = item.getBoundingClientRect();
            const offset = e.clientY - (box.top + box.height / 2);
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: item };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
        items.forEach(item => {
            item.style.opacity = '1';
            item.classList.remove('drop-target');
        });
        if (afterElement) {
            afterElement.style.opacity = '0.4';
            afterElement.classList.add('drop-target');
        }
    }
    function handleDrop(e) {
        e.preventDefault();
        const data = JSON.parse(e.dataTransfer.getData('text/plain'));
        const targetContainer = e.target.closest('.data-items');
        if (!targetContainer) return;
        document.querySelectorAll('.data-item').forEach(item => {
            item.style.opacity = '1';
            item.classList.remove('drop-target');
        });
        const sourceType = data.type;
        const sourceCategory = data.category;
        const targetType = targetContainer.dataset.type;
        const targetCategory = targetContainer.dataset.category;
        const dropTarget = e.target.closest('.data-item');
        const targetIndex = dropTarget ?
            Array.from(targetContainer.children).indexOf(dropTarget) :
            targetContainer.children.length;
        moveItem(sourceType, sourceCategory, parseInt(data.index), targetType, targetCategory, targetIndex);
        updateUI();
    }
    function handleDragEnd(e) {
        e.target.classList.remove('dragging');
        document.querySelectorAll('.data-item').forEach(item => {
            item.style.opacity = '1';
            item.classList.remove('drop-target');
        });
    }
    function moveItem(fromType, fromCategory, fromIndex, toType, toCategory, toIndex) {
        const sourceCat = apiData[fromType].category.find(c => c.name === fromCategory);
        const targetCat = apiData[toType].category.find(c => c.name === toCategory);
        if (sourceCat && sourceCat.data && targetCat) {
            if (!targetCat.data) targetCat.data = [];
            const [item] = sourceCat.data.splice(fromIndex, 1);
            targetCat.data.splice(toIndex, 0, item);
        }
    }
    // --- Add New Item ---
    document.getElementById('addNewItem').addEventListener('click', function() {
        const mainType = document.getElementById('mainType').value;
        const category = document.getElementById('category').value;
        const text = document.getElementById('symbolText').value.trim();
        const api = document.getElementById('apiCode').value.trim();
        // Prompt for multi-language name
        const nameTh = prompt("ใส่ชื่อภาษาไทย (optional):","");
        const nameEn = prompt("ใส่ชื่อภาษาอังกฤษ (optional):","");
        if (!validateInput(text, api)) return;
        let categoryData = apiData[mainType].category.find(c => c.name === category);
        if (!categoryData) {
            // Try to find nameObj in categoryNameMap
            let nameObj = { th: category, en: category };
            if (categoryNameMap[mainType]) {
                const found = categoryNameMap[mainType].find(x => x.en === category);
                if (found) nameObj = found;
            }
            categoryData = { name: category, nameObj, data: [] };
            apiData[mainType].category.push(categoryData);
        }
        if (!categoryData.data) categoryData.data = [];
        categoryData.data.push({
            api,
            text,
            nameObj: { th: nameTh || "", en: nameEn || "" }
        });
        clearForm();
        updateUI();
        showToast('เพิ่มข้อมูลสำเร็จ', 'success');
    });

    // --- Add New Category (with multi-language) ---
    document.getElementById('addNewCategory').addEventListener('click', function() {
        const nameTh = prompt('ชื่อหมวดหมู่ใหม่ (ภาษาไทย):');
        const nameEn = prompt('ชื่อหมวดหมู่ใหม่ (English):');
        if (nameTh && nameEn) {
            const mainType = document.getElementById('mainType').value;
            if (!apiData[mainType].category.some(c => c.name === nameEn)) {
                apiData[mainType].category.push({
                    name: nameEn,
                    nameObj: { th: nameTh, en: nameEn },
                    data: []
                });
                // update category name map also
                if (!categoryNameMap[mainType]) categoryNameMap[mainType] = [];
                categoryNameMap[mainType].push({ th: nameTh, en: nameEn });
                updateUI();
                showToast('เพิ่มหมวดหมู่สำเร็จ', 'success');
            } else {
                showToast('หมวดหมู่นี้มีอยู่แล้ว', 'error');
            }
        }
    });

    function validateInput(text, api) {
        if (!text || !api) {
            showToast('กรุณากรอกข้อมูลให้ครบ', 'error');
            return false;
        }
        const apiFormat = /^(U\+[\dA-F]{4,6}|\\u[\dA-F]{4,6})$/i;
        if (!apiFormat.test(api)) {
            showToast('รูปแบบรหัส API ไม่ถูกต้อง', 'error');
            return false;
        }
        return true;
    }
    function clearForm() {
        document.getElementById('symbolText').value = '';
        document.getElementById('apiCode').value = '';
    }
    function showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.textContent = message;
        const container = document.getElementById('toastContainer');
        container.appendChild(toast);
        setTimeout(() => { toast.remove(); }, 3000);
    }
    document.getElementById('themeSwitcher').addEventListener('click', function() {
        isDarkMode = !isDarkMode;
        localStorage.setItem('darkMode', isDarkMode);
        updateTheme();
    });

    searchInput.addEventListener('input', debounce(renderData, 300));
    filterType.addEventListener('change', renderData);
    filterCategory.addEventListener('change', renderData);
    document.getElementById('mainType').addEventListener('change', updateCategorySelect);

    // --- Copy JSON (export in new format!) ---
    document.getElementById('copyJSON').addEventListener('click', function() {
        // Convert to new format
        const jsonString = JSON.stringify(oldToNewFormat(apiData), null, 2);
        navigator.clipboard.writeText(jsonString)
            .then(() => showToast('คัดลอก JSON สำเร็จ', 'success'))
            .catch(() => showToast('ไม่สามารถคัดลอก JSON ได้', 'error'));
    });

    // --- Export CSV (text, api, nameTH, nameEN) ---
    document.getElementById('exportCSV').addEventListener('click', function() {
        const csv = convertToCSV();
        downloadCSV(csv);
        showToast('ส่งออก CSV สำเร็จ', 'success');
    });

    // --- Utility: Debounce, CSV, Download ---
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    function convertToCSV() {
        const rows = [['Type', 'Category', 'Text', 'API Code', 'Name(TH)', 'Name(EN)']];
        Object.entries(apiData).forEach(([type, data]) => {
            if (data.category) {
                data.category.forEach(category => {
                    if (category.data) {
                        category.data.forEach(item => {
                            rows.push([
                                type,
                                category.name,
                                item.text,
                                item.api,
                                (item.nameObj && item.nameObj.th) || "",
                                (item.nameObj && item.nameObj.en) || ""
                            ]);
                        });
                    }
                });
            }
        });
        return rows.map(row =>
            row.map(cell => `"${(cell || '').toString().replace(/"/g, '""')}"`).join(',')
        ).join('\n');
    }

    function downloadCSV(csv) {
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `api_database_${new Date().toISOString().slice(0,10)}.csv`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }

    // --- Init ---
    loadInitialData();
});