/**
 * header.js - Enhanced version (แก้ไขปัญหาการนำทางและ URL)
 */
document.addEventListener('DOMContentLoaded', () => {
    // ประกาศตัวแปรสำหรับใช้ทั้งไฟล์
    const state = {
        isRendering: false,
        debounceTimer: null,
        buttonConfig: null,
        cache: new Map(),
        navigationState: {
            isNavigating: false,
            currentMainRoute: '',
            currentSubRoute: '',
            isInitialLoad: true,
            previousUrl: ''
        }
    };

    // Element selectors
    const elements = {
        header: document.querySelector('header'),
        navButtons: document.querySelectorAll('nav ul li button'),
        logo: document.querySelector('.logo'),
        navList: document.getElementById('nav-list'),
        subButtonsContainer: document.getElementById('sub-buttons-container')
    };

    // Constants
    const CONSTANTS = {
        ANIMATION_DURATION: 300,
        SCROLL_THRESHOLD: 1.27,
        CACHE_DURATION: 5 * 60 * 1000, // 5 minutes
        FETCH_TIMEOUT: 5000,
        RETRY_DELAY: 2000,
        MAX_RETRIES: 3
    };

// ระบบจัดการข้อผิดพลาดที่ปรับปรุงใหม่
class ErrorManager {
  constructor() {
    this.errorStates = new Map();
    this.timeouts = new Map();
  }

  // ตรวจสอบความถูกต้องของข้อผิดพลาด
  isValidError(error) {
    return error && (
      error instanceof Error ||
      error.message ||
      typeof error === 'string'
    );
  }

  // ตรวจสอบว่าเป็นข้อผิดพลาดเดิมหรือไม่
  isDuplicateError(errorKey, message) {
    const existingError = this.errorStates.get(errorKey);
    return existingError && existingError.message === message;
  }

  // จัดการแสดงข้อผิดพลาด
  showError(errorKey, error, options = {}) {
    if (!this.isValidError(error)) return;

    const message = error.message || error.toString();
    
    // ถ้าเป็นข้อผิดพลาดเดิม ไม่ต้องแสดงซ้ำ
    if (this.isDuplicateError(errorKey, message)) return;

    // เคลียร์ timeout เดิมถ้ามี
    if (this.timeouts.has(errorKey)) {
      clearTimeout(this.timeouts.get(errorKey));
    }

    // บันทึกสถานะข้อผิดพลาด
    this.errorStates.set(errorKey, {
      message,
      timestamp: Date.now(),
      type: options.type || 'error'
    });

    // แสดงข้อผิดพลาด
    utils.showNotification(message, options.type || 'error', {
      duration: options.duration || 3000,
      position: options.position || 'top',
      dismissible: options.dismissible !== false
    });

    // ตั้งเวลาลบสถานะข้อผิดพลาด
    const timeout = setTimeout(() => {
      this.errorStates.delete(errorKey);
      this.timeouts.delete(errorKey);
    }, options.duration || 3000);

    this.timeouts.set(errorKey, timeout);
  }

  // เคลียร์ข้อผิดพลาดทั้งหมด
  clearErrors() {
    this.errorStates.clear();
    this.timeouts.forEach(clearTimeout);
    this.timeouts.clear();
  }
}

// สร้าง instance เดียวสำหรับใช้ทั้งระบบ
const errorManager = new ErrorManager();

const utils = {
    // ค่าคงที่สำหรับการตั้งค่าต่างๆ
    CONSTANTS: {
        ANIMATION_DURATION: 300, // ระยะเวลาของ animation (ms)
        NOTIFICATION_DURATION: 3000, // ระยะเวลาแสดง notification (ms)
        DEBOUNCE_DELAY: 250, // ระยะเวลาหน่วง debounce (ms)
        THROTTLE_DELAY: 100, // ระยะเวลาหน่วง throttle (ms)
        MAX_CACHE_SIZE: 100, // ขนาดสูงสุดของ cache
        MAX_RETRIES: 3, // จำนวนครั้งสูงสุดในการลองใหม่
        ERROR_TIMEOUT: 5000 // ระยะเวลาแสดงข้อผิดพลาด (ms)
    },

    // ระบบ Cache
    cache: new Map(),

    // เก็บ notification ที่กำลังแสดงอยู่
    activeNotifications: new Set(),

    // ระบบจัดการข้อผิดพลาด
    errorHandling: {
        errors: new Map(),
        errorCount: 0,
        lastErrorTime: 0
    },

    /**
     * แสดง notification
     * @param {string} message - ข้อความที่จะแสดง
     * @param {string} type - ประเภท (success, error, warning, info)
     * @param {Object} options - ตัวเลือกเพิ่มเติม
     */
// แก้ไขฟังก์ชัน showNotification ในส่วนของ utils:
showNotification(message, type = 'info', options = {}) {
 const lang = localStorage.getItem('selectedLang') || 'en';
 
 // ข้อความในแต่ละภาษา
 const messages = {
  th: {
   success: '✨ สำเร็จ!',
   error: '❌ ข้อผิดพลาด',
   warning: '⚠️ คำเตือน',
   info: 'ℹ️ ข้อมูล',
   loading: '⌛ กำลังโหลด'
  },
  en: {
   success: '✨ Success!',
   error: '❌ Error',
   warning: '⚠️ Warning',
   info: 'ℹ️ Information',
   loading: '⌛ Loading'
  }
  // สามารถเพิ่มภาษาอื่นๆ ได้ตามต้องการ
 };
 
 try {
  // ลบ notification เก่าถ้ามีการระบุ key เดียวกัน
  if (options.key) {
   const existingNotification = document.querySelector(`.notification[data-key="${options.key}"]`);
   if (existingNotification) {
    existingNotification.style.animation = 'fadeOut 0.2s ease forwards';
    setTimeout(() => existingNotification.remove(), 200);
   }
  }
  
  // สร้าง notification ใหม่
  const notification = document.createElement('div');
  notification.className = `notification notification-${type}`;
  if (options.key) {
   notification.setAttribute('data-key', options.key);
  }
  notification.setAttribute('data-timestamp', Date.now());
  
  // สร้าง container สำหรับ animation
  const animContainer = document.createElement('div');
  animContainer.className = 'notification-anim-container';
  
  // สร้างไอคอน
  const icon = document.createElement('div');
  icon.className = 'notification-icon';
  icon.innerHTML = type === 'success' ? '✓' :
   type === 'error' ? '✕' :
   type === 'warning' ? '⚠' :
   type === 'loading' ? '⌛' : 'ℹ';
  
  // สร้างส่วนข้อความ
  const messageContainer = document.createElement('div');
  messageContainer.className = 'notification-message-container';
  messageContainer.innerHTML = `
            <div class="notification-title">${messages[lang][type]}</div>
            <div class="notification-content">${message}</div>
        `;
  
  // สร้างปุ่มปิดถ้า dismissible
  if (options.dismissible !== false) {
   const closeButton = document.createElement('button');
   closeButton.className = 'notification-close';
   closeButton.innerHTML = '×';
   closeButton.onclick = () => {
    notification.style.animation = 'slideOut 0.3s ease forwards';
    setTimeout(() => notification.remove(), 300);
   };
   animContainer.appendChild(closeButton);
  }
  
  animContainer.appendChild(icon);
  animContainer.appendChild(messageContainer);
  notification.appendChild(animContainer);
  
  // เพิ่ม styles ถ้ายังไม่มี
  if (!document.querySelector('#notification-styles')) {
   const style = document.createElement('style');
   style.id = 'notification-styles';
   style.textContent = `
                .notification {
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 16px;
                    border-radius: 12px;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
                    z-index: 10000;
                    opacity: 0;
                    transform: translateY(-20px);
                    animation: slideIn 0.3s ease forwards;
                    max-width: 400px;
                    backdrop-filter: blur(10px);
                    color: white;
                }

                .notification-success {
                    background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
                }

                .notification-error {
                    background: linear-gradient(135deg, #f44336 0%, #e53935 100%);
                }

                .notification-warning {
                    background: linear-gradient(135deg, #ff9800 0%, #fb8c00 100%);
                }

                .notification-info {
                    background: linear-gradient(135deg, #2196f3 0%, #1e88e5 100%);
                }

                .notification-loading {
                    background: linear-gradient(135deg, #9e9e9e 0%, #757575 100%);
                }

                .notification-anim-container {
                    display: flex;
                    align-items: center;
                    gap: 12px;
                }

                .notification-icon {
                    background: rgba(255,255,255,0.2);
                    width: 32px;
                    height: 32px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 18px;
                    animation: scaleIn 0.3s ease forwards;
                }

                .notification-message-container {
                    flex: 1;
                }

                .notification-title {
                    font-size: 16px;
                    font-weight: 600;
                    margin-bottom: 4px;
                }

                .notification-content {
                    font-size: 14px;
                    opacity: 0.9;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }

                .notification-close {
                    background: none;
                    border: none;
                    color: white;
                    font-size: 20px;
                    cursor: pointer;
                    padding: 0;
                    width: 24px;
                    height: 24px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    opacity: 0.8;
                    transition: opacity 0.2s;
                }

                .notification-close:hover {
                    opacity: 1;
                }

                @keyframes slideIn {
                    from {
                        opacity: 0;
                        transform: translateY(-20px);
                    }
                    to {
                        opacity: 1;
                        transform: translateY(0);
                    }
                }

                @keyframes scaleIn {
                    from {
                        transform: scale(0);
                    }
                    to {
                        transform: scale(1);
                    }
                }

                @keyframes fadeOut {
                    from {
                        opacity: 1;
                        transform: translateY(0);
                    }
                    to {
                        opacity: 0;
                        transform: translateY(-10px);
                    }
                }

                @keyframes slideOut {
                    from {
                        opacity: 1;
                        transform: translateY(0);
                    }
                    to {
                        opacity: 0;
                        transform: translateY(-20px);
                    }
                }

                .notification-loading .notification-icon {
                    animation: spin 1s linear infinite;
                }

                @keyframes spin {
                    from {
                        transform: rotate(0deg);
                    }
                    to {
                        transform: rotate(360deg);
                    }
                }
            `;
   document.head.appendChild(style);
  }
  
  document.body.appendChild(notification);
  
  // ตั้งเวลาลบ notification ถ้าไม่ใช่ loading และมีการกำหนด duration
  if (type !== 'loading' && options.duration !== Infinity) {
   setTimeout(() => {
    if (document.body.contains(notification)) {
     notification.style.animation = 'slideOut 0.3s ease forwards';
     setTimeout(() => {
      if (document.body.contains(notification)) {
       notification.remove();
      }
     }, 300);
    }
   }, options.duration || 3000);
  }
  
  return notification;
 } catch (error) {
  console.error('Error showing notification:', error);
 }
},

    /**
     * ลบ notification
     */
    removeNotification(notification, key) {
        if (!document.body.contains(notification)) return;

        notification.style.opacity = '0';
        notification.style.transform = 'translateY(-20px)';

        setTimeout(() => {
            if (document.body.contains(notification)) {
                document.body.removeChild(notification);
                this.activeNotifications.delete(key);
            }
        }, 300);
    },

    /**
     * สร้างเนื้อหา notification
     */
    createNotificationContent(message, type, showIcon) {
        const content = document.createElement('div');
        content.className = 'notification-content';

        if (showIcon) {
            const icon = this.createIcon(type);
            content.appendChild(icon);
        }

        const messageElement = document.createElement('span');
        messageElement.className = 'notification-message';
        messageElement.textContent = message;
        content.appendChild(messageElement);

        return content;
    },

    /**
     * สร้างปุ่มปิด notification
     */
    createCloseButton(onClose) {
        const closeButton = document.createElement('button');
        closeButton.className = 'notification-close';
        closeButton.innerHTML = '×';
        closeButton.onclick = onClose;
        return closeButton;
    },

    /**
     * สร้าง progress bar
     */
    createProgressBar(duration) {
        const progress = document.createElement('div');
        progress.className = 'notification-progress';
        progress.style.animation = `notification-progress ${duration}ms linear`;
        return progress;
    },

    /**
     * สร้างไอคอน
     */
    createIcon(type) {
        const icon = document.createElement('span');
        icon.className = 'notification-icon';
        
        const iconContent = {
            success: '✓',
            error: '!',
            warning: '⚠',
            info: 'ℹ',
            loading: '+'
        };

        icon.textContent = iconContent[type] || 'ℹ';
        if (type === 'loading') {
            icon.style.animation = 'spin 1s linear infinite';
        }
        
        return icon;
    },

    /**
     * กำหนดตำแหน่ง notification
     */
    setNotificationPosition(notification, position) {
        const positions = {
            'top-right': { top: '20px', right: '20px' },
            'top-left': { top: '20px', left: '20px' },
            'bottom-right': { bottom: '20px', right: '20px' },
            'bottom-left': { bottom: '20px', left: '20px' },
            'top-center': { top: '20px', left: '50%', transform: 'translateX(-50%)' },
            'bottom-center': { bottom: '20px', left: '50%', transform: 'translateX(-50%)' }
        };

        const pos = positions[position] || positions['top-right'];
        Object.assign(notification.style, pos);
    },

    /**
     * จัดการ animation ของ notification
     */
    animateNotification(notification, duration) {
        requestAnimationFrame(() => {
            notification.style.opacity = '0';
            notification.style.transform = 'translateY(-20px)';
            
            requestAnimationFrame(() => {
                notification.style.transition = `all ${duration}ms ease`;
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            });
        });
    },

    /**
     * Debounce function
     */
    debounce(func, wait = this.CONSTANTS.DEBOUNCE_DELAY) {
        let timeout;
        return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    },

    /**
     * Throttle function
     */
    throttle(func, limit = this.CONSTANTS.THROTTLE_DELAY) {
        let inThrottle;
        return (...args) => {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    },

    /**
     * คัดลอกข้อความไปยัง clipboard
     */
// แก้ไขฟังก์ชัน copyToClipboard ในส่วนของ utils:
async copyToClipboard(content) {
 const lang = localStorage.getItem('selectedLang') || 'en';
 
 const messages = {
  th: {
   success: '✨ คัดลอกสำเร็จแล้ว!',
   error: '❌ ไม่สามารถคัดลอกได้',
   copied: 'คัดลอกแล้ว:'
  },
  en: {
   success: '✨ Copied successfully!',
   error: '❌ Could not copy',
   copied: 'Copied:'
  }
 };
 
 try {
  await navigator.clipboard.writeText(content);
  
  // ลบ notification เก่าถ้ามี
  const existingNotification = document.querySelector('.copy-notification');
  if (existingNotification) {
   // ทำ animation การจางหายให้กับ notification เก่า
   existingNotification.style.animation = 'fadeOut 0.2s ease forwards';
   
   // รอให้ animation จบก่อนลบ
   await new Promise(resolve => {
    existingNotification.addEventListener('animationend', () => {
     existingNotification.remove();
     resolve();
    }, { once: true });
    
    // Fallback ในกรณีที่ animation ไม่ทำงาน
    setTimeout(() => {
     if (document.body.contains(existingNotification)) {
      existingNotification.remove();
      resolve();
     }
    }, 200);
   });
  }
  
  // สร้าง notification ใหม่
  const notification = document.createElement('div');
  notification.className = 'copy-notification';
  notification.setAttribute('data-timestamp', Date.now());
  
  // สร้าง animation container
  const animContainer = document.createElement('div');
  animContainer.className = 'copy-anim-container';
  
  // เพิ่มไอคอนแบบ animated
  const icon = document.createElement('div');
  icon.className = 'copy-icon';
  icon.innerHTML = '✓';
  
  // สร้างส่วนข้อความ
  const message = document.createElement('div');
  message.className = 'copy-message';
  message.innerHTML = `
            <div class="copy-title">${messages[lang].success}</div>
            <div class="copy-content">${messages[lang].copied} ${content}</div>
        `;
  
  animContainer.appendChild(icon);
  animContainer.appendChild(message);
  notification.appendChild(animContainer);
  
  // เพิ่ม CSS สำหรับ notification
  if (!document.querySelector('#copy-notification-styles')) {
   const style = document.createElement('style');
   style.id = 'copy-notification-styles';
   style.textContent = `
                .copy-notification {
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
                    color: white;
                    padding: 16px;
                    border-radius: 12px;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
                    z-index: 10000;
                    opacity: 0;
                    transform: translateY(-20px);
                    animation: slideIn 0.3s ease forwards;
                    max-width: 400px;
                    backdrop-filter: blur(10px);
                    transition: all 0.3s ease;
                }

                .copy-anim-container {
                    display: flex;
                    align-items: center;
                    gap: 12px;
                }

                .copy-icon {
                    background: rgba(255,255,255,0.2);
                    width: 32px;
                    height: 32px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 18px;
                    animation: scaleIn 0.3s ease forwards;
                }

                .copy-message {
                    flex: 1;
                }

                .copy-title {
                    font-size: 16px;
                    font-weight: 600;
                    margin-bottom: 4px;
                }

                .copy-content {
                    font-size: 14px;
                    opacity: 0.9;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }

                @keyframes slideIn {
                    from {
                        opacity: 0;
                        transform: translateY(-20px);
                    }
                    to {
                        opacity: 1;
                        transform: translateY(0);
                    }
                }

                @keyframes scaleIn {
                    from {
                        transform: scale(0);
                    }
                    to {
                        transform: scale(1);
                    }
                }

                @keyframes fadeOut {
                    from {
                        opacity: 1;
                        transform: translateY(0);
                    }
                    to {
                        opacity: 0;
                        transform: translateY(-10px);
                    }
                }

                @keyframes slideOut {
                    from {
                        opacity: 1;
                        transform: translateY(0);
                    }
                    to {
                        opacity: 0;
                        transform: translateY(-20px);
                    }
                }
            `;
   document.head.appendChild(style);
  }
  
  document.body.appendChild(notification);
  
  // ตั้งเวลาลบ notification
  setTimeout(() => {
   if (document.body.contains(notification)) {
    notification.style.animation = 'slideOut 0.3s ease forwards';
    setTimeout(() => {
     if (document.body.contains(notification)) {
      notification.remove();
     }
    }, 300);
   }
  }, 3000);
  
 } catch (error) {
  throw new Error(messages[lang].error);
 }
},

    /**
     * จัดการข้อผิดพลาด
     */
    handleError(error, context = '') {
        const now = Date.now();
        const errorKey = error.message || 'unknown';
        
        // เพิ่มจำนวนข้อผิดพลาด
        this.errorHandling.errorCount++;
        this.errorHandling.lastErrorTime = now;
        
        // บันทึกข้อผิดพลาด
        const currentErrors = this.errorHandling.errors.get(errorKey) || 0;
        this.errorHandling.errors.set(errorKey, currentErrors + 1);

        // แสดงข้อความแจ้งเตือน
        this.showNotification(
            `เกิดข้อผิดพลาด${context ? ' ใน' + context : ''}: ${error.message}`,
            'error',
            { duration: this.CONSTANTS.ERROR_TIMEOUT }
        );

        // ส่งข้อมูลไปยังระบบติดตามข้อผิดพลาด (ถ้ามี)
        if (this.errorHandling.errorCount > 5) {
            // แจ้งเตือนว่ามีข้อผิดพลาดมากเกินไป
            this.showNotification(
                'พบข้อผิดพลาดหลายครั้ง กรุณารีเฟรชหน้าเว็บ',
                'error',
                { duration: this.CONSTANTS.ERROR_TIMEOUT }
            );
        }
    },

    /**
     * เช็คการเชื่อมต่ออินเทอร์เน็ต
     */
    isOnline() {
        return navigator.onLine;
    },

    /**
     * จัดการ Cache
     */
    setCache(key, data, expiry = 5 * 60 * 1000) {
        if (this.cache.size >= this.CONSTANTS.MAX_CACHE_SIZE) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }

        this.cache.set(key, {
            data,
            expiry: Date.now() + expiry
        });
    },

    getCache(key) {
        const cached = this.cache.get(key);
        if (!cached) return null;

        if (Date.now() > cached.expiry) {
            this.cache.delete(key);
            return null;
        }

        return cached.data;
    },

    clearCache() {
        this.cache.clear();
    },

    /**
     * รีเซ็ตสถานะทั้งหมด
     */
    reset() {
        this.cache.clear();
        this.activeNotifications.clear();
        this.errorHandling.errors.clear();
        this.errorHandling.errorCount = 0;
        this.errorHandling.lastErrorTime = 0;
    }
};

// เพิ่ม CSS สำหรับ notifications
const style = document.createElement('style');
style.textContent = `
  .notification {
    position: fixed;
    padding: 12px;
    margin: 8px;
    border-radius: 4px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    z-index: 9999;
    background: white;
    min-width: 250px;
  }

  .notification-success { background-color: #4caf50; color: white; }
  .notification-error { background-color: #f44336; color: white; }
  .notification-warning { background-color: #ff9800; color: white; }
  .notification-info { background-color: #2196f3; color: white; }
  .notification-loading { background-color: #9e9e9e; color: white; }

  .notification-content {
    flex: 1;
    display: flex;
    align-items: center;
  }

  .notification-icon {
    margin-right: 8px;
    font-size: 18px;
  }

  .notification-message {
    flex: 1;
  }

  .notification-close {
    background: none;
    border: none;
    color: inherit;
    font-size: 20px;
    cursor: pointer;
    padding: 0 4px;
    margin-left: 8px;
  }

  .notification-progress {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 3px;
    background: rgba(255,255,255,0.3);
  }

  @keyframes notification-progress {
    from { width: 100%; }
    to { width: 0%; }
  }

  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }
`;

document.head.appendChild(style);

const NavigationManager = {
    // สถานะการนำทาง
    state: {
        isNavigating: false,
        currentMainRoute: '',
        currentSubRoute: '',
        isInitialLoad: true,
        previousUrl: '',
        lastScrollPosition: 0
    },

    // ประวัติการนำทาง
    history: [],
    maxHistory: 50,

    // เพิ่มประวัติการนำทาง
/**
 * ฟังก์ชัน addToHistory ปรับปรุงให้บันทึกประวัติเฉพาะเมื่อเกิดการคลิกของผู้ใช้
 * และจะตรวจสอบความซ้ำซ้อนกับรายการล่าสุดและกับ window.location.hash
 * นอกจากนี้ยังใช้ flag hasRecordedInitialHistory เพื่อลดการบันทึกประวัติ 
 *ที่เป็นผลจากการโหลดหน้าแรกหรือระบบที่ทำงานแทนผู้ใช้
 */
addToHistory(url, type = 'user') {
 const normalizedUrl = this.normalizeUrl(url);
 
 // ตรวจสอบ flag ให้แน่ใจว่า หากเป็นรายการแรกจากการโหลดหน้าเว็บ เราจะไม่บันทึก
 if (!this.hasRecordedInitialHistory) {
  // ตรวจสอบกับ window.location.hash (ถ้า hash ตรงกับ normalizedUrl)
  const currentHash = window.location.hash.replace('#', '');
  if (normalizedUrl === currentHash) {
   console.log("ไม่บันทึกประวัติ: URL ตรงกับ hash เริ่มต้น");
   this.hasRecordedInitialHistory = true;
   return;
  }
 }
 
 // ตรวจสอบรายการสุดท้ายที่บันทึกใน custom historyว่าซ้ำกันหรือไม่
 if (this.history && this.history.length > 0) {
  if (this.history[0].url === normalizedUrl) {
   console.log("ไม่บันทึกประวัติซ้ำ: " + normalizedUrl);
   return;
  }
 } else {
  this.history = [];
 }
 
 // บันทึกประวัติใหม่
 this.history.unshift({
  url: normalizedUrl,
  type: type,
  timestamp: Date.now()
 });
 
 // จำกัดจำนวนรายการใน custom history
 if (this.history.length > this.maxHistory) {
  this.history.pop();
 }
 
 console.log("เพิ่มประวัติใหม่: " + normalizedUrl);
},

    // ทำความสะอาด URL
    normalizeUrl(url) {
        if (!url) return '';
        return url.toLowerCase().trim().replace(/^#/, '');
    },

    // เปรียบเทียบ URL
    compareUrls(url1, url2) {
        return this.normalizeUrl(url1) === this.normalizeUrl(url2);
    },

    // ตรวจสอบความถูกต้องของ URL
    async validateUrl(url) {
        if (!url) return false;
        
        try {
            if (!state.buttonConfig) {
                await ButtonManager.loadConfig();
            }

            const [mainRoute, subRoute] = url.split('-');
            const mainButton = state.buttonConfig.mainButtons.find(
                btn => btn.url === mainRoute || btn.jsonFile === mainRoute
            );

            if (!mainButton) return false;

            // ถ้ามี subRoute ต้องตรวจสอบด้วย
            if (subRoute) {
                return await this.validateSubRoute(mainButton, subRoute);
            }

            return true;
        } catch (error) {
            console.error('เกิดข้อผิดพลาดในการตรวจสอบ URL:', error);
            return false;
        }
    },

    // ตรวจสอบความถูกต้องของ URL ย่อย
    async validateSubRoute(mainButton, subRoute) {
        if (!mainButton || !subRoute) return false;
        if (!mainButton.subButtons) return false;

        return mainButton.subButtons.some(
            sub => sub.url === subRoute || sub.jsonFile === subRoute
        );
    },

async navigateTo(route, options = {}) {
    // 1. ตรวจสอบการนำทางที่ซ้ำซ้อน
    if (this.state.isNavigating) {
        console.log('กำลังนำทางอยู่ กรุณารอสักครู่...');
        return;
    }
    
    try {
        this.state.isNavigating = true;
        this.state.lastScrollPosition = window.pageYOffset;
        
        // 2. ตรวจสอบความถูกต้องของ URL ด้วย validateUrl()
        let isValidUrl = false;
        try {
            isValidUrl = await this.validateUrl(route);
        } catch (e) {
            console.error("การตรวจสอบ URL ล้มเหลว:", e);
        }
        
        if (!isValidUrl) {
            console.warn('URL ไม่ถูกต้อง จะใช้ default route แทน');
            try {
                route = await this.getDefaultRoute();
            } catch (e) {
                console.error("ไม่สามารถดึง default route ได้:", e);
                throw new Error('ไม่สามารถดึง default route ได้');
            }
        }
        
        // 3. แยก main route กับ sub route จาก URL 
        const [newMainRoute, newSubRoute] = route.split('-');
        const previousMainRoute = this.state.currentMainRoute;
        const previousSubRoute = this.state.currentSubRoute;
        this.state.currentMainRoute = newMainRoute;
        this.state.currentSubRoute = newSubRoute || '';
        
        // 4. อัพเดท URL หากไม่ได้ระบุให้ข้ามการอัพเดท URL
        if (!options.skipUrlUpdate) {
            try {
                await this.changeURL(route);
            } catch (urlError) {
                console.error("การเปลี่ยน URL ล้มเหลว:", urlError);
                utils.showNotification('ไม่สามารถเปลี่ยน URL ได้', 'error');
            }
        }
        
        // 5. หา main button จาก config
        const mainButton = state.buttonConfig.mainButtons.find(btn =>
            btn.url === newMainRoute || btn.jsonFile === newMainRoute
        );
        if (!mainButton) {
            console.error(`ไม่พบปุ่มหลักสำหรับ route: ${newMainRoute}`);
            throw new Error(`ไม่พบปุ่มหลักสำหรับ route: ${newMainRoute}`);
        }
        
        // 6. ตรวจสอบการเปลี่ยนแปลงของ main และ sub route
        const mainChanged = previousMainRoute !== newMainRoute;
        const subChanged = previousSubRoute !== newSubRoute;
        
        // 7. จัดการการโหลดเนื้อหาตามประเภทของปุ่ม
        if (mainButton.subButtons && mainButton.subButtons.length > 0) {
            // กรณีมีปุ่มย่อย
            if (mainChanged || !newSubRoute) {
                try {
                    await ContentManager.clearContent();
                } catch (clearError) {
                    console.error("การล้างเนื้อหาล้มเหลว:", clearError);
                }
                
                // ล้าง container ของปุ่มย่อย
                elements.subButtonsContainer.innerHTML = "";
                
                try {
                    await ButtonManager.renderSubButtons(
                        mainButton.subButtons,
                        newMainRoute,
                        localStorage.getItem('selectedLang') || 'en'
                    );
                } catch (subRenderError) {
                    console.error("การเรนเดอร์ปุ่มย่อยล้มเหลว:", subRenderError);
                }
                
                let targetSubButton = null;
                if (!newSubRoute) {
                    // ดึง default sub-button (หรือ sub-button แรก)
                    targetSubButton = mainButton.subButtons.find(btn => btn.isDefault) || mainButton.subButtons[0];
                    
                    // อัพเดท state ให้มี sub route จาก default
                    this.state.currentSubRoute = targetSubButton.url || targetSubButton.jsonFile;
                    
                    // รวม route ใหม่ที่มี default sub route
                    const combinedRoute = `${newMainRoute}-${this.state.currentSubRoute}`;
                    if (!options.skipUrlUpdate) {
                        try {
                            await this.changeURL(combinedRoute, true);
                        } catch (changeCombinedError) {
                            console.error("เปลี่ยน URL ด้วย default sub route ล้มเหลว:", changeCombinedError);
                        }
                    }
                } else {
                    targetSubButton = mainButton.subButtons.find(
                        btn => btn.url === newSubRoute || btn.jsonFile === newSubRoute
                    );
                }
                
                if (targetSubButton && targetSubButton.jsonFile) {
                    try {
                        await ContentManager.clearContent();
                        const subData = await DataManager.fetchWithRetry(targetSubButton.jsonFile);
                        await ContentManager.renderContent(subData);
                    } catch (subContentError) {
                        console.error("การดึงหรือเรนเดอร์เนื้อหาของ sub button ล้มเหลว:", subContentError);
                        throw subContentError;
                    }
                }
            } else if (subChanged && newSubRoute) {
                const subButtonConfig = mainButton.subButtons.find(
                    btn => btn.url === newSubRoute || btn.jsonFile === newSubRoute
                );
                if (subButtonConfig && subButtonConfig.jsonFile) {
                    try {
                        await ContentManager.clearContent();
                        const subData = await DataManager.fetchWithRetry(subButtonConfig.jsonFile);
                        await ContentManager.renderContent(subData);
                    } catch (subChangeError) {
                        console.error("การดึงหรือเรนเดอร์เนื้อหาของ sub button ที่เปลี่ยนแปลงล้มเหลว:", subChangeError);
                        throw subChangeError;
                    }
                }
            } else {
                console.log("main button และ sub route ยังไม่เปลี่ยนแปลง ไม่ต้องโหลดเนื้อหาใหม่");
            }
        } else {
            // กรณีปุ่มหลักไม่มีปุ่มย่อย
            if (mainChanged) {
                try {
                    await ContentManager.clearContent();
                } catch (mainClearError) {
                    console.error("การล้างเนื้อหาของ main button ล้มเหลว:", mainClearError);
                }
                if (mainButton.jsonFile) {
                    try {
                        const mainData = await DataManager.fetchWithRetry(mainButton.jsonFile);
                        await ContentManager.renderContent(mainData);
                    } catch (mainContentError) {
                        console.error("การดึงหรือเรนเดอร์เนื้อหาของ main button ล้มเหลว:", mainContentError);
                        throw mainContentError;
                    }
                }
            }
        }
        
        // 8. อัพเดทสถานะ active ของปุ่ม
        try {
            await this.updateButtonStates(route);
        } catch (updateStateError) {
            console.error("การอัพเดทสถานะของปุ่มล้มเหลว:", updateStateError);
        }
        
        // 9. เลื่อนหน้าจอ ถ้าไม่ได้ระบุให้รักษาตำแหน่ง scroll
        if (!options.maintainScroll) {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        console.log(`นำทางเรียบร้อยแล้ว: ${newMainRoute} ${this.state.currentSubRoute ? '-' + this.state.currentSubRoute : ''}`);
        
    } catch (error) {
        console.error('เกิดข้อผิดพลาดในการนำทาง:', error);
        utils.showNotification('เกิดข้อผิดพลาดในการนำทาง', 'error');
        throw error;
    } finally {
        this.state.isNavigating = false;
    }
},

    // หา default route
    async getDefaultRoute() {
        try {
            if (!state.buttonConfig) {
                await ButtonManager.loadConfig();
            }
            
            const defaultMainButton = state.buttonConfig.mainButtons.find(btn => btn.isDefault);
            if (!defaultMainButton) return '';

            const mainRoute = defaultMainButton.url || defaultMainButton.jsonFile;
            
            if (!defaultMainButton.subButtons) return mainRoute;

            const defaultSubButton = defaultMainButton.subButtons.find(btn => btn.isDefault);
            if (!defaultSubButton) return mainRoute;

            const subRoute = defaultSubButton.url || defaultSubButton.jsonFile;
            return `${mainRoute}-${subRoute}`;
        } catch (error) {
            console.error('เกิดข้อผิดพลาดในการหา default route:', error);
            return '';
        }
    },

    // อัพเดท URL
    async changeURL(url, force = false) {
        try {
            if (!url) return;
            const newUrl = url.includes('#') ? url : `#${url}`;
            
            if (force || window.location.hash !== newUrl) {
                history.pushState(
                    { 
                        url: newUrl,
                        scrollPosition: this.state.lastScrollPosition
                    },
                    '',
                    newUrl
                );
                
                this.state.previousUrl = newUrl;
                
                window.dispatchEvent(new CustomEvent('urlChanged', {
                    detail: { 
                        url: newUrl,
                        mainRoute: this.state.currentMainRoute,
                        subRoute: this.state.currentSubRoute
                    }
                }));
            }
        } catch (error) {
            console.error('เกิดข้อผิดพลาดในการเปลี่ยน URL:', error);
            throw new Error('ไม่สามารถเปลี่ยน URL ได้');
        }
    },

    // อัพเดทสถานะปุ่ม
    async updateButtonStates(route) {
        try {
            const normalizedRoute = this.normalizeUrl(route);
            const [mainRoute, subRoute] = normalizedRoute.split('-');

            // ล้างสถานะปุ่มทั้งหมด
            document.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('active');
            });

            // อัพเดทปุ่มหลัก
            const mainButton = document.querySelector(`button[data-url="${mainRoute}"]`);
            if (mainButton) {
                mainButton.classList.add('active');
            }

            // อัพเดทปุ่มย่อย
            if (subRoute) {
                const subButton = document.querySelector(`button[data-url="${normalizedRoute}"]`);
                if (subButton) {
                    subButton.classList.add('active');
                }
            }

            // เลื่อนปุ่มที่ active เข้ามาในมุมมอง
            this.scrollActiveButtonsIntoView();

        } catch (error) {
            console.error('เกิดข้อผิดพลาดในการอัพเดทสถานะปุ่ม:', error);
        }
    },

    // เลื่อนปุ่มที่ active เข้ามาในมุมมอง
    scrollActiveButtonsIntoView() {
        try {
            ['nav ul', '#sub-buttons-container'].forEach(selector => {
                const container = document.querySelector(selector);
                if (!container) return;
                
                const activeButton = container.querySelector('button.active');
                if (!activeButton) return;

                requestAnimationFrame(() => {
                    try {
                        const containerBounds = container.getBoundingClientRect();
                        const buttonBounds = activeButton.getBoundingClientRect();
                        
                        const scrollLeft = container.scrollLeft + 
                            (buttonBounds.left - containerBounds.left) - 20;
                        
                        container.scrollTo({
                            left: Math.max(0, scrollLeft),
                            behavior: 'smooth'
                        });
                    } catch (error) {
                        console.warn('เกิดข้อผิดพลาดในการเลื่อนปุ่ม:', error);
                    }
                });
            });
        } catch (error) {
            console.warn('เกิดข้อผิดพลาดในฟังก์ชัน scrollActiveButtonsIntoView:', error);
        }
    },

    // ตรวจสอบสถานะ elements
    validateElements() {
        const required = ['header', 'navButtons', 'logo', 'navList', 'subButtonsContainer'];
        const missing = required.filter(key => !elements[key]);
        
        if (missing.length > 0) {
            console.warn('ไม่พบ elements ที่จำเป็น:', missing.join(', '));
            return false;
        }
        return true;
    },

    // จัดการการ refresh
    handleRefresh() {
        const currentHash = window.location.hash.replace('#', '');
        if (currentHash) {
            this.navigateTo(currentHash, { skipUrlUpdate: true });
        } else {
            this.navigateTo(this.getDefaultRoute());
        }
    },

    // รีเซ็ตสถานะทั้งหมด
    reset() {
        this.state = {
            isNavigating: false,
            currentMainRoute: '',
            currentSubRoute: '',
            isInitialLoad: true,
            previousUrl: '',
            lastScrollPosition: 0
        };
        this.history = [];
    }
};

// แก้ไขเป็น:
window.addEventListener('resize', () => {
 NavigationManager.scrollActiveButtonsIntoView();
});

// เพิ่ม Event Listener สำหรับการโหลดหน้าเว็บครั้งแรก
document.addEventListener('DOMContentLoaded', () => {
 NavigationManager.updateButtonStates();
});

// Content Management
const ContentManager = {
  async clearContent() {
    const contentElements = document.querySelectorAll('[id^="content-"]');

    await Promise.all(
      Array.from(contentElements).map(element => {
        return new Promise(resolve => {
          const handleAnimationEnd = () => {
            element.innerHTML = '';
            element.classList.remove('fade-out');
            element.removeEventListener('animationend', handleAnimationEnd);
            resolve();
          };

          element.addEventListener('animationend', handleAnimationEnd);
          element.classList.add('fade-out');

          // Fallback
          setTimeout(handleAnimationEnd, CONSTANTS.ANIMATION_DURATION);
        });
      })
    );
  },

  async renderContent(data) {
    if (!Array.isArray(data)) {
      throw new AppError('ข้อมูลที่ได้รับไม่ใช่อาร์เรย์', 'render');
    }

    await this.clearContent();
    if (state.isRendering) return;

    state.isRendering = true;

    try {
      await Promise.all(
        data.map(async item => {
          const targetElement = document.getElementById(item.id);
          if (!targetElement) return;

          targetElement.innerHTML = '';
          const container = this.createContainer(item);

          if (item.group?.items) {
            await this.renderGroupItems(container, item.group);
          } else {
            await this.renderSingleItem(container, item);
          }

          targetElement.appendChild(container);
        })
      );
    } finally {
      state.isRendering = false;
    }
  },

  createContainer(item) {
    const container = document.createElement('div');
    container.className =
      item.group?.type === 'button'
        ? 'button-content-container'
        : 'card-content-container';

    // เพิ่ม custom class สำหรับ container ถ้ามีการระบุ
    if (item.group?.containerClass) {
      container.classList.add(item.group.containerClass);
    }

    return container;
  },

  async renderGroupItems(container, group) {
    // เพิ่มการสร้าง Group Header ถ้ามีการระบุ
    if (group.header) {
      const headerElement = this.createGroupHeader(group.header);
      container.appendChild(headerElement);
    }

    // สำหรับกลุ่มที่เป็น button type เราจะส่ง object ทั้งหมดเพื่อให้รองรับทั้ง api และ content
    const renderPromises = group.items.map(item =>
      group.type === 'button'
        ? this.createButton(item)
        : this.createCard(item)
    );

    const elements = await Promise.all(renderPromises);
    elements.forEach(element => {
      if (element) container.appendChild(element);
    });
  },

  // ปรับปรุงโครงสร้างของ Group Header ให้เรียบง่ายขึ้น
  createGroupHeader(headerConfig) {
    // สร้าง container หลัก
    const headerContainer = document.createElement('div');
    headerContainer.className = 'group-header';

    // รับภาษาปัจจุบัน
    const currentLang = localStorage.getItem('selectedLang') || 'en';

    // ถ้า headerConfig เป็น string ให้ใช้ createSimpleHeader
    if (typeof headerConfig === 'string') {
      return this.createSimpleHeader(headerConfig, headerContainer);
    }

    // เพิ่ม custom class ถ้ามี
    if (headerConfig.className) {
      headerContainer.classList.add(headerConfig.className);
    }

    // สร้างส่วนประกอบต่างๆ
    this.createHeaderComponents(headerContainer, headerConfig, currentLang);

    // เพิ่ม event listener สำหรับการเปลี่ยนภาษา
    this.addLanguageChangeListener(headerContainer, headerConfig);

    return headerContainer;
  },

  // สร้าง header แบบง่าย
  createSimpleHeader(text, container) {
    const headerText = document.createElement('h2');
    headerText.className = 'group-header-text';
    headerText.textContent = text;
    container.appendChild(headerText);
    return container;
  },

  // สร้างส่วนประกอบของ header
  createHeaderComponents(container, config, currentLang) {
    // 1. สร้างไอคอน (ถ้ามี)
    if (config.icon) {
      container.appendChild(this.createHeaderIcon(config.icon));
    }

    // 2. สร้างส่วนหัว
    const headerContent = document.createElement('div');
    headerContent.className = 'header-content';

    // 2.1 สร้างหัวข้อ
    const title = this.createHeaderTitle(config, currentLang);
    headerContent.appendChild(title);

    // 2.2 สร้างคำอธิบาย (ถ้ามี)
    if (config.description) {
      const desc = this.createHeaderDescription(config.description, currentLang);
      headerContent.appendChild(desc);
    }

    container.appendChild(headerContent);

    // 3. สร้างปุ่มเสริม (ถ้ามี)
    if (config.actions) {
      container.appendChild(this.createHeaderActions(config.actions, currentLang));
    }
  },

  // สร้างหัวข้อ
  createHeaderTitle(config, currentLang) {
    const title = document.createElement('h2');
    title.className = 'group-header-text';

    // เก็บข้อมูลภาษาใน data attributes
    if (typeof config.title === 'object') {
      Object.entries(config.title).forEach(([lang, text]) => {
        title.dataset[`title${lang.toUpperCase()}`] = text;
      });
      title.textContent = config.title[currentLang] || config.title.en;
    } else {
      title.textContent = config.title;
    }

    return title;
  },

  // สร้างคำอธิบาย
  createHeaderDescription(description, currentLang) {
    const desc = document.createElement('p');
    desc.className = 'group-header-description';

    if (typeof description === 'object') {
      Object.entries(description).forEach(([lang, text]) => {
        desc.dataset[`desc${lang.toUpperCase()}`] = text;
      });
      desc.textContent = description[currentLang] || description.en;
    } else {
      desc.textContent = description;
    }

    return desc;
  },

  // เพิ่ม event listener สำหรับการเปลี่ยนภาษาใน header
  addLanguageChangeListener(container, config) {
    window.addEventListener('languageChange', event => {
      const newLang = event.detail.language;
      this.updateHeaderLanguage(container, config, newLang);
    });
  },

  // ฟังก์ชัน updateHeaderLanguage (สามารถกำหนดเพิ่มเองได้ตามความต้องการ)
  updateHeaderLanguage(container, config, newLang) {
    // ตัวอย่างการอัพเดทภาษาใน header
    const titleElement = container.querySelector('.group-header-text');
    if (titleElement && config.title) {
      if (typeof config.title === 'object') {
        titleElement.textContent =
          config.title[newLang] || config.title.en || titleElement.textContent;
      }
    }
    const descElement = container.querySelector('.group-header-description');
    if (descElement && config.description) {
      if (typeof config.description === 'object') {
        descElement.textContent =
          config.description[newLang] ||
          config.description.en ||
          descElement.textContent;
      }
    }
  },

  async renderSingleItem(container, item) {
    const element =
      item.type === 'button'
        ? await this.createButton(item)
        : await this.createCard(item);

    if (element) container.appendChild(element);
  },

  async createButton(config) {
    const button = document.createElement('button');
    button.className = 'button-content';
    let finalContent = '';

    try {
      // ถ้ามีการระบุ api ให้ดึงข้อมูลจากฐานข้อมูล API
      if (config.api) {
        finalContent = await DataManager.fetchApiContent(config.api);
      } else if (config.content) {
        finalContent = config.content;
      } else {
        throw new Error('ต้องระบุ api หรือ content สำหรับ button content type');
      }
      button.textContent = finalContent;
    } catch (error) {
      console.error('Error creating button:', error);
      button.textContent = 'Error';
    }

    const wrapper = document.createElement('div');
    wrapper.appendChild(button);

    button.addEventListener('click', async () => {
      try {
        await utils.copyToClipboard(finalContent);
      } catch (error) {
        utils.showNotification(error.message, 'error');
      }
    });

    return this.animateElement(wrapper);
  },

  async createCard(cardConfig) {
    const lang = localStorage.getItem('selectedLang') || 'en';
    // สร้าง element สำหรับการ์ดในรูปแบบ <button>
    const card = document.createElement('div');
    card.className = 'card';

    // จัดการรูปภาพ (ถ้ามี)
    if (cardConfig.image) {
      const img = document.createElement('img');
      img.className = 'card-image';
      img.src = cardConfig.image;
      img.loading = 'lazy';
      // รองรับ alt text หลายภาษา
      img.alt =
        cardConfig.imageAlt?.[lang] ||
        cardConfig.imageAlt?.en ||
        '';
      card.appendChild(img);
    }

    // สร้าง container สำหรับเนื้อหาการ์ด
    const contentDiv = document.createElement('div');
    contentDiv.className = 'card-content';

    // จัดการหัวข้อการ์ด
    const titleDiv = document.createElement('div');
    titleDiv.className = 'card-title';
    if (typeof cardConfig.title === 'object') {
      Object.entries(cardConfig.title).forEach(([langCode, text]) => {
        titleDiv.dataset[`title${langCode.toUpperCase()}`] = text;
      });
      titleDiv.textContent = cardConfig.title[lang] || cardConfig.title.en;
    } else {
      titleDiv.textContent = cardConfig.title;
    }
    contentDiv.appendChild(titleDiv);

    // จัดการคำอธิบายของการ์ด
    const descDiv = document.createElement('div');
    descDiv.className = 'card-description';
    if (typeof cardConfig.description === 'object') {
      Object.entries(cardConfig.description).forEach(([langCode, text]) => {
        descDiv.dataset[`desc${langCode.toUpperCase()}`] = text;
      });
      descDiv.textContent = cardConfig.description[lang] || cardConfig.description.en;
    } else {
      descDiv.textContent = cardConfig.description;
    }
    contentDiv.appendChild(descDiv);

    // นำ container เนื้อหาการ์ดไปใส่ภายในปุ่มการ์ด
    card.appendChild(contentDiv);

    // จัดการลิงก์ให้กับการ์ด (ถ้ามี)
    if (cardConfig.link) {
      card.addEventListener('click', () => {
        window.open(cardConfig.link, '_blank', 'noopener');
      });
    }

    // เพิ่มคลาสเพิ่มเติมถ้ามีการกำหนดใน config
    if (cardConfig.className) {
      card.classList.add(cardConfig.className);
    }

    // คืนค่า element การ์ดที่ได้หลังจาก animation
    return this.animateElement(card);
  },

  updateCardsLanguage(lang) {
    document.querySelectorAll('.card').forEach(card => {
      // อัพเดทหัวข้อ
      const titleElement = card.querySelector('.card-title');
      if (titleElement) {
        const newTitle = titleElement.dataset[`title${lang.toUpperCase()}`];
        if (newTitle) {
          titleElement.textContent = newTitle;
        }
      }

      // อัพเดทคำอธิบาย
      const descElement = card.querySelector('.card-description');
      if (descElement) {
        const newDesc = descElement.dataset[`desc${lang.toUpperCase()}`];
        if (newDesc) {
          descElement.textContent = newDesc;
        }
      }

      // อัพเดท alt text ของรูปภาพ
      const imgElement = card.querySelector('.card-image');
      if (imgElement) {
        const newAlt = imgElement.dataset[`alt${lang.toUpperCase()}`];
        if (newAlt) {
          imgElement.alt = newAlt;
        }
      }
    });
  },

  async animateElement(element) {
    return new Promise(resolve => {
      requestAnimationFrame(() => {
        const handleAnimationEnd = () => {
          element.removeEventListener('animationend', handleAnimationEnd);
          resolve(element);
        };

        element.addEventListener('animationend', handleAnimationEnd);
        element.classList.add('fade-in');

        // Fallback
        setTimeout(() => handleAnimationEnd(), CONSTANTS.ANIMATION_DURATION);
      });
    });
  }
};

const DataManager = {
  // ค่าคงที่สำหรับการตั้งค่าต่างๆ
  constants: {
    FETCH_TIMEOUT: 8000,      // 8 วินาที
    RETRY_DELAY: 2000,        // 2 วินาที
    MAX_RETRIES: 3,
    CACHE_DURATION: 5 * 60 * 1000, // 5 นาที
    BATCH_SIZE: 10,
    MAX_CACHE_SIZE: 100,
    API_DATABASE_PATH: '/assets/json/api-database.json'
  },

  // ข้อความแสดงผลหลายภาษา
  messages: {
    th: {
      loading: 'กำลังโหลดข้อมูล...',
      retrying: 'กำลังลองใหม่... (ครั้งที่ {attempt}/{max})',
      error: 'เกิดข้อผิดพลาดในการโหลดข้อมูล',
      offline: 'ไม่มีการเชื่อมต่ออินเทอร์เน็ต กรุณาตรวจสอบการเชื่อมต่อ',
      timeout: 'การโหลดข้อมูลใช้เวลานานเกินไป',
      cacheCleared: 'ล้างแคชเรียบร้อย',
      batchLoading: 'กำลังโหลด {current}/{total}',
      batchError: 'เกิดข้อผิดพลาดในการโหลดบางส่วน แต่จะดำเนินการต่อ',
      invalidData: 'ข้อมูลไม่ถูกต้อง',
      networkError: 'เกิดข้อผิดพลาดในการเชื่อมต่อ',
      apiNotFound: 'ไม่พบข้อมูลสำหรับ API code: {code}',
      apiDatabaseError: 'เกิดข้อผิดพลาดในการโหลดฐานข้อมูล API',
      invalidApiData: 'ข้อมูล API ไม่ถูกต้อง'
    },
    en: {
      loading: 'Loading data...',
      retrying: 'Retrying... (Attempt {attempt}/{max})',
      error: 'Error loading data',
      offline: 'No internet connection. Please check your connection.',
      timeout: 'Request timeout',
      cacheCleared: 'Cache cleared successfully',
      batchLoading: 'Loading {current}/{total}',
      batchError: 'Error loading some items, but continuing',
      invalidData: 'Invalid data received',
      networkError: 'Network connection error',
      apiNotFound: 'API code not found: {code}',
      apiDatabaseError: 'Error loading API database',
      invalidApiData: 'Invalid API data'
    }
  },

  // เก็บข้อมูลแคช
  cache: new Map(),
  
  // เก็บแคช API database
  apiCache: null,
  apiCacheTimestamp: 0,

  // เก็บสถานะการโหลด
  loadingStates: new Map(),

  // ดึงข้อความตามภาษาที่เลือก
  getMessage(key, params = {}) {
    const currentLang = localStorage.getItem('selectedLang') || 'en';
    let message = this.messages[currentLang]?.[key] || 
                  this.messages['en'][key];
    
    Object.entries(params).forEach(([key, value]) => {
      message = message.replace(`{${key}}`, value);
    });
    
    return message;
  },

  // ตรวจสอบการเชื่อมต่ออินเทอร์เน็ต
  isOnline() {
    return navigator.onLine;
  },

  // เช็คว่าข้อมูลในแคชหมดอายุหรือยัง
  isCacheExpired(timestamp) {
    return Date.now() - timestamp > this.constants.CACHE_DURATION;
  },

  // ดึงข้อมูลจากแคช
  getCached(key) {
    const cached = this.cache.get(key);
    if (!cached) return null;
    
    if (this.isCacheExpired(cached.timestamp)) {
      this.cache.delete(key);
      return null;
    }
    
    return cached.data;
  },

  // เก็บข้อมูลลงแคช
  setCache(key, data) {
    // ตรวจสอบขนาดของแคช
    if (this.cache.size >= this.constants.MAX_CACHE_SIZE) {
      // หาและลบรายการที่เก่าที่สุด
      let oldestKey = null;
      let oldestTime = Date.now();
      
      for (const [k, v] of this.cache.entries()) {
        if (v.timestamp < oldestTime) {
          oldestKey = k;
          oldestTime = v.timestamp;
        }
      }
      
      if (oldestKey) {
        this.cache.delete(oldestKey);
      }
    }
    
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  },

  // ล้างแคชทั้งหมด
  clearCache() {
    this.cache.clear();
    this.apiCache = null;
    this.apiCacheTimestamp = 0;
    utils.showNotification(
      this.getMessage('cacheCleared'),
      'success',
      { duration: 3000 }
    );
  },

  // ล้างแคชที่หมดอายุ
  clearExpiredCache() {
    for (const [key, value] of this.cache.entries()) {
      if (this.isCacheExpired(value.timestamp)) {
        this.cache.delete(key);
      }
    }
    
    // เช็คแคช API database
    if (this.apiCache && this.isCacheExpired(this.apiCacheTimestamp)) {
      this.apiCache = null;
      this.apiCacheTimestamp = 0;
    }
  },

  // สร้าง URL สำหรับการเรียก API
  buildUrl(baseUrl, params = {}) {
    try {
      const url = new URL(baseUrl, window.location.origin);
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          url.searchParams.append(key, value);
        }
      });
      return url.toString();
    } catch (error) {
      throw new Error(`ไม่สามารถสร้าง URL ได้: ${error.message}`);
    }
  },

  // ดึงข้อมูลพร้อม timeout
  async fetchWithTimeout(url, options = {}) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort();
    }, this.constants.FETCH_TIMEOUT);
    
    try {
      if (!this.isOnline()) {
        throw new Error(this.getMessage('offline'));
      }
      
      const response = await fetch(url, {
        ...options,
        signal: controller.signal,
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        }
      });
      
      if (!response.ok) {
        throw new Error(`${this.getMessage('error')}: ${response.status} ${response.statusText}`);
      }
      
      const data = await response.json();
      
      if (!data || (Array.isArray(data) && data.length === 0)) {
        throw new Error(this.getMessage('invalidData'));
      }
      
      return data;
      
    } finally {
      clearTimeout(timeoutId);
    }
  },

  // ดึงข้อมูลพร้อมระบบลองใหม่อัตโนมัติ
  async fetchWithRetry(url, options = {}) {
    const key = `${url}-${JSON.stringify(options)}`;
    
    // เช็คแคชก่อน
    const cachedData = this.getCached(key);
    if (cachedData) {
      return cachedData;
    }
    
    // แสดงสถานะกำลังโหลด
    LoadingManager.show(key, this.getMessage('loading'));
    
    let lastError;
    for (let attempt = 1; attempt <= this.constants.MAX_RETRIES; attempt++) {
      try {
        if (!this.isOnline()) {
          throw new Error(this.getMessage('offline'));
        }

        const data = await this.fetchWithTimeout(url, options);
        
        if (options.cache !== false) {
          this.setCache(key, data);
        }
        
        LoadingManager.hide(key);
        return data;
        
      } catch (error) {
        lastError = error;
        
        if (attempt < this.constants.MAX_RETRIES) {
          utils.showNotification(
            this.getMessage('retrying', {
              attempt: attempt + 1,
              max: this.constants.MAX_RETRIES
            }),
            'info',
            { duration: this.constants.RETRY_DELAY }
          );
          
          await new Promise(resolve =>
            setTimeout(resolve, this.constants.RETRY_DELAY)
          );
        }
      }
    }
    
    LoadingManager.hide(key);
    const errorMessage = lastError.name === 'TimeoutError' ? 
      this.getMessage('timeout') : 
      this.getMessage('networkError');

    errorManager.showError(key, new Error(errorMessage), {
      duration: 5000,
      type: 'error',
      dismissible: true,
      position: 'top-right'
    });
    
    throw lastError;
  },

  // โหลดฐานข้อมูล API
  async loadApiDatabase() {
    // เช็คแคชก่อน
    if (this.apiCache && !this.isCacheExpired(this.apiCacheTimestamp)) {
      return this.apiCache;
    }

    try {
      const data = await this.fetchWithRetry(this.constants.API_DATABASE_PATH);
      
      // ตรวจสอบความถูกต้องของข้อมูล
      if (!data || !Array.isArray(data.items)) {
        throw new Error(this.getMessage('invalidApiData'));
      }

      // เก็บในแคช
      this.apiCache = data.items;
      this.apiCacheTimestamp = Date.now();

      return data.items;

    } catch (error) {
      console.error('Error loading API database:', error);
      throw new Error(this.getMessage('apiDatabaseError'));
    }
  },

// ปรับปรุงฟังก์ชัน fetchApiContent ใน DataManager
async fetchApiContent(apiCode) {
    try {
        // โหลด API database
        const response = await this.fetchWithRetry('/assets/json/api-database.json');
        
        // ฟังก์ชันช่วยค้นหา API code ในทุกหมวดหมู่
        const findApiContent = (data) => {
            // ฟังก์ชันวนหาใน category
            const searchInCategories = (categories) => {
                for (const category of categories) {
                    if (category.data) {
                        // ค้นหาใน data array ของแต่ละ category
                        const found = category.data.find(item => item.api === apiCode);
                        if (found) return found.text;
                    }
                }
                return null;
            };
            
            // วนหาในทุก type (emoji, symbol, etc.)
            for (const type in data) {
                if (data[type].category) {
                    const result = searchInCategories(data[type].category);
                    if (result) return result;
                }
            }
            return null;
        };
        
        // ค้นหา API code
        const content = findApiContent(response);
        
        if (!content) {
            throw new Error(this.getMessage('apiNotFound', { code: apiCode }));
        }
        
        return content;
        
    } catch (error) {
        console.error('เกิดข้อผิดพลาดในการดึงข้อมูล API:', error);
        throw new Error(`ไม่สามารถดึงข้อมูล API ได้: ${error.message}`);
    }
},

  // โหลดข้อมูลแบบแบ่งชุด
  async fetchBatched(urls, options = {}) {
    const results = [];
    const batches = [];
    
    // แบ่งเป็นชุดๆ
    for (let i = 0; i < urls.length; i += this.constants.BATCH_SIZE) {
      batches.push(urls.slice(i, i + this.constants.BATCH_SIZE));
    }
    
    let completed = 0;
    const total = urls.length;
    
    // โหลดทีละชุด
    for (const batch of batches) {
      try {
        const batchResults = await Promise.all(
          batch.map(async url => {
            const result = await this.fetchWithRetry(url, {
              ...options,
              loadingMessage: this.getMessage('batchLoading', {
                current: ++completed,
                total
              })
            });
            return result;
          })
        );
        results.push(...batchResults);
      } catch (error) {
        utils.showNotification(
          this.getMessage('batchError'),
          'warning'
        );
      }
    }
    
    return results;
  },

  // เริ่มต้นระบบ
  init() {
    // ล้างแคชที่หมดอายุทุก 5 นาที
    setInterval(() => {
      this.clearExpiredCache();
    }, this.constants.CACHE_DURATION);
    
    // ติดตามสถานะการเชื่อมต่อ
    window.addEventListener('online', () => {
      utils.showNotification(
        this.getMessage('online'),
        'success'
      );
    });
    
    window.addEventListener('offline', () => {
      utils.showNotification(
        this.getMessage('offline'),
        'warning'
      );
    });

    // ติดตามการเปลี่ยนภาษา
    window.addEventListener('languageChange', () => {
      // รีเฟรชข้อความที่กำลังแสดงอยู่ถ้าจำเป็น
      this.loadingStates.forEach((state, key) => {
        if (state.loading) {
          LoadingManager.updateMessage(key, this.getMessage('loading'));
        }
      });
    });
  },

  // เคลียร์สถานะทั้งหมด
  reset() {
    this.clearCache();
    this.loadingStates.clear();
    LoadingManager.clearAll();
  }
};

// เริ่มต้นระบบเมื่อโหลดเพจ
document.addEventListener('DOMContentLoaded', () => {
  DataManager.init();
});

const LoadingManager = {
  // เก็บ state ของ loaders และ timeout handlers
  loaders: new Map(),
  timeoutHandlers: new Map(),
  loadingStates: new Map(),
  
  // ค่าคงที่สำหรับการตั้งค่าต่างๆ
  CONSTANTS: {
    DEFAULT_TIMEOUT: 15000, // 15 วินาที
    MIN_DISPLAY_TIME: 500,  // แสดงอย่างน้อย 0.5 วินาที
    FADE_DURATION: 300,     // ระยะเวลา fade animation
    POSITION: {
      LOADING: 'bottom-right',
      ERROR: 'top-right'
    }
  },

  /**
   * แสดง loading indicator
   * @param {string} key - คีย์สำหรับระบุ loader
   * @param {string} message - ข้อความที่จะแสดง
   * @param {Object} options - ตัวเลือกเพิ่มเติม
   */
  show(key, message = 'กำลังโหลดข้อมูล...', options = {}) {
    // ถ้ามี loader เดิมอยู่แล้ว ให้ลบออกก่อน
    if (this.loaders.has(key)) {
      this.hide(key);
    }

    // บันทึกเวลาเริ่มต้น
    const startTime = Date.now();
    this.loadingStates.set(key, { startTime });

    // สร้าง loader ใหม่
    const loader = utils.showNotification(message, 'loading', {
      duration: Infinity,
      dismissible: false,
      position: options.position || this.CONSTANTS.POSITION.LOADING,
      className: 'loading-indicator',
      icon: true,
      progress: true
    });

    this.loaders.set(key, loader);

    // ตั้งค่า timeout สำหรับตรวจสอบการโหลดที่นานเกินไป
    const timeoutDuration = options.timeout || this.CONSTANTS.DEFAULT_TIMEOUT;
    const timeoutHandler = setTimeout(() => {
      if (this.loaders.has(key)) {
        this.handleTimeout(key, message);
      }
    }, timeoutDuration);

    // เก็บ timeout handler
    this.timeoutHandlers.set(key, timeoutHandler);

    return loader;
  },

  /**
   * จัดการกรณีที่การโหลดใช้เวลานานเกินไป
   * @param {string} key - คีย์ของ loader
   * @param {string} originalMessage - ข้อความเดิมที่กำลังโหลด
   */
  handleTimeout(key, originalMessage) {
    this.hide(key);
    
    const errorMessage = `ไม่สามารถ${originalMessage.toLowerCase()}ได้ เนื่องจากใช้เวลานานเกินไป`;
    errorManager.showError(key, new Error(errorMessage), {
      type: 'error',
      duration: 5000,
      position: this.CONSTANTS.POSITION.ERROR,
      dismissible: true,
      actions: [{
        label: 'ลองใหม่',
        onClick: () => {
          // ส่ง event เพื่อให้ component ที่เกี่ยวข้องจัดการการโหลดใหม่
          window.dispatchEvent(new CustomEvent('retryLoading', { detail: { key } }));
        }
      }]
    });
  },

  /**
   * ซ่อน loading indicator
   * @param {string} key - คีย์ของ loader
   * @param {Object} options - ตัวเลือกเพิ่มเติม
   */
  async hide(key, options = {}) {
    // ยกเลิก timeout
    if (this.timeoutHandlers.has(key)) {
      clearTimeout(this.timeoutHandlers.get(key));
      this.timeoutHandlers.delete(key);
    }

    const loader = this.loaders.get(key);
    if (!loader) return;

    // ตรวจสอบเวลาขั้นต่ำในการแสดง
    const loadingState = this.loadingStates.get(key);
    if (loadingState) {
      const elapsedTime = Date.now() - loadingState.startTime;
      if (elapsedTime < this.CONSTANTS.MIN_DISPLAY_TIME) {
        await new Promise(resolve => 
          setTimeout(resolve, this.CONSTANTS.MIN_DISPLAY_TIME - elapsedTime)
        );
      }
    }

    // ทำ animation ก่อนลบ
    if (!options.skipAnimation) {
      loader.style.opacity = '0';
      await new Promise(resolve => 
        setTimeout(resolve, this.CONSTANTS.FADE_DURATION)
      );
    }

    // ลบ loader
    loader.remove();
    this.loaders.delete(key);
    this.loadingStates.delete(key);
  },

  /**
   * อัพเดตข้อความของ loading indicator
   * @param {string} key - คีย์ของ loader
   * @param {string} message - ข้อความใหม่
   */
  updateMessage(key, message) {
    const loader = this.loaders.get(key);
    if (loader) {
      const messageElement = loader.querySelector('.notification-message');
      if (messageElement) {
        messageElement.textContent = message;
      }
    }
  },

  /**
   * เช็คว่ากำลังโหลดอยู่หรือไม่
   * @param {string} key - คีย์ของ loader
   * @returns {boolean}
   */
  isLoading(key) {
    return this.loaders.has(key);
  },

  /**
   * เคลียร์ทุก loader และ timeout
   * @param {Object} options - ตัวเลือกเพิ่มเติม
   */
  clearAll(options = {}) {
    // ยกเลิกทุก timeout
    this.timeoutHandlers.forEach(handler => clearTimeout(handler));
    this.timeoutHandlers.clear();

    // ลบทุก loader
    const hidePromises = Array.from(this.loaders.keys()).map(key => 
      this.hide(key, options)
    );

    // รอให้ทุก loader ถูกลบ
    return Promise.all(hidePromises);
  },

  /**
   * รีเซ็ตสถานะทั้งหมด
   */
  reset() {
    this.clearAll({ skipAnimation: true });
    this.loadingStates.clear();
  }
};

// เพิ่ม Event Listeners สำหรับจัดการสถานะ loading ในระดับแอพพลิเคชัน
window.addEventListener('load', () => {
  // จัดการกรณีรีเฟรชหน้า
  LoadingManager.reset();
});

window.addEventListener('beforeunload', () => {
  // เคลียร์สถานะก่อนออกจากหน้า
  LoadingManager.reset();
});

// จัดการกรณีเปลี่ยนหน้าใน SPA
window.addEventListener('popstate', () => {
  LoadingManager.clearAll();
});

// จัดการกรณีเครือข่ายมีปัญหา
window.addEventListener('offline', () => {
  LoadingManager.clearAll();
  utils.showNotification(
    'ขาดการเชื่อมต่ออินเทอร์เน็ต กรุณาตรวจสอบการเชื่อมต่อของคุณ',
    'warning',
    { duration: 0 }  // แสดงจนกว่าจะกลับมาออนไลน์
  );
});

window.addEventListener('online', () => {
  utils.showNotification(
    'กลับมาออนไลน์แล้ว',
    'success',
    { duration: 3000 }
  );
});

// ScrollManager ที่ปรับปรุงใหม่ใช้ Animation-based
const ScrollManager = {
 init() {
  // ตัวแปรสำหรับควบคุมสถานะ
  const state = {
   isAnimating: false,
   lastScrollY: window.pageYOffset,
   headerVisible: true,
   animationFrame: null,
   headerHeight: 0,
   scrollDirection: 0,
   scrollTimeout: null
  };
  
  // ค่าคงที่สำหรับการปรับแต่ง
  const SETTINGS = {
   // ระยะ scroll ขั้นต่ำที่จะเริ่มทำงาน (px)
   SCROLL_THRESHOLD: 5,
   // ความเร็วในการแสดง/ซ่อน header (ms)
   ANIMATION_DURATION: 400,
   // ระยะเวลารอก่อนรีเซ็ต header (ms)
   RESET_DELAY: 0,
   // ระยะการเลื่อนขั้นต่ำที่จะเริ่มตรวจจับทิศทาง (px)
   DIRECTION_THRESHOLD: 1,
   // ความเร็วในการ scroll ที่จะทริกเกอร์ animation (px/ms)
   VELOCITY_THRESHOLD: 0.3
  };
  
  // Keyframes สำหรับ animation
  const ANIMATIONS = {
   hideHeader: [
    { transform: 'translateY(0)', offset: 0 },
    { transform: 'translateY(-52%)', offset: 1 }
   ],
   showHeader: [
    { transform: 'translateY(-52%)', offset: 0 },
    { transform: 'translateY(0)', offset: 1 }
   ]
  };
  
  // Animation timing
  const TIMING = {
   duration: SETTINGS.ANIMATION_DURATION,
   easing: 'cubic-bezier(0.4, 0.0, 0.2, 1)', // Material Design easing
   fill: 'forwards'
  };
  
  // ฟังก์ชันสำหรับคำนวณความเร็วการ scroll
  const calculateScrollVelocity = (() => {
   let lastScrollY = window.pageYOffset;
   let lastScrollTime = performance.now();
   
   return () => {
    const currentScrollY = window.pageYOffset;
    const currentTime = performance.now();
    const timeDiff = currentTime - lastScrollTime;
    const scrollDiff = currentScrollY - lastScrollY;
    
    lastScrollY = currentScrollY;
    lastScrollTime = currentTime;
    
    return timeDiff > 0 ? scrollDiff / timeDiff : 0;
   };
  })();
  
  // ฟังก์ชันจัดการ animation
  const animateHeader = (show) => {
   const { header } = elements;
   if (!header || state.isAnimating) return;
   
   // ยกเลิก animation ที่กำลังเล่นอยู่
   header.getAnimations().forEach(animation => animation.cancel());
   
   // สร้างและเริ่ม animation ใหม่
   const animation = header.animate(
    show ? ANIMATIONS.showHeader : ANIMATIONS.hideHeader,
    TIMING
   );
   
   state.isAnimating = true;
   state.headerVisible = show;
   
   animation.onfinish = () => {
    state.isAnimating = false;
   };
  };
  
  // ฟังก์ชันหลักจัดการ scroll
  const handleScroll = () => {
   if (state.animationFrame) {
    cancelAnimationFrame(state.animationFrame);
   }
   
   state.animationFrame = requestAnimationFrame(() => {
    const currentScrollY = window.pageYOffset;
    const scrollDiff = currentScrollY - state.lastScrollY;
    const velocity = calculateScrollVelocity();
    
    // ตรวจสอบทิศทางและความเร็วของการ scroll
    if (Math.abs(scrollDiff) > SETTINGS.DIRECTION_THRESHOLD) {
     const scrollingDown = scrollDiff > 0;
     const velocityTriggered = Math.abs(velocity) > SETTINGS.VELOCITY_THRESHOLD;
     
     // เช็คเงื่อนไขการแสดง/ซ่อน header
     if (currentScrollY > SETTINGS.SCROLL_THRESHOLD) {
      if (scrollingDown && state.headerVisible && velocityTriggered) {
       // ซ่อน header เมื่อเลื่อนลงเร็วๆ
       animateHeader(false);
      } else if (!scrollingDown && !state.headerVisible && velocityTriggered) {
       // แสดง header เมื่อเลื่อนขึ้นเร็วๆ
       animateHeader(true);
      }
     } else if (currentScrollY <= 0 && !state.headerVisible) {
      // แสดง header เมื่ออยู่บนสุด
      animateHeader(true);
     }
    }
    
    state.lastScrollY = currentScrollY;
    state.scrollDirection = scrollDiff;
   });
   
   // รีเซ็ต timeout สำหรับการตรวจสอบการหยุด scroll
   clearTimeout(state.scrollTimeout);
   state.scrollTimeout = setTimeout(() => {
    const currentScrollY = window.pageYOffset;
    if (currentScrollY <= SETTINGS.SCROLL_THRESHOLD && !state.headerVisible) {
     animateHeader(true);
    }
   }, SETTINGS.RESET_DELAY);
  };
  
  // Touch handling สำหรับมือถือ
  let touchStartY = 0;
  let lastTouchY = 0;
  let touchStartTime = 0;
  
  const handleTouchStart = (e) => {
   touchStartY = e.touches[0].clientY;
   lastTouchY = touchStartY;
   touchStartTime = performance.now();
   state.isAnimating = false;
  };
  
  const handleTouchMove = (e) => {
   const currentY = e.touches[0].clientY;
   const touchDiff = currentY - lastTouchY;
   const timeDiff = performance.now() - touchStartTime;
   const velocity = touchDiff / timeDiff;
   
   if (Math.abs(velocity) > SETTINGS.VELOCITY_THRESHOLD) {
    if (velocity > 0 && !state.headerVisible) {
     animateHeader(true);
    } else if (velocity < 0 && state.headerVisible) {
     animateHeader(false);
    }
   }
   
   lastTouchY = currentY;
  };
  
  // Event Listeners
  window.addEventListener('scroll', handleScroll, { passive: true });
  window.addEventListener('touchstart', handleTouchStart, { passive: true });
  window.addEventListener('touchmove', handleTouchMove, { passive: true });
  
  // Resize Observer
  const resizeObserver = new ResizeObserver((entries) => {
   for (const entry of entries) {
    if (entry.target === elements.header) {
     state.headerHeight = entry.contentRect.height;
    }
   }
  });
  
  if (elements.header) {
   resizeObserver.observe(elements.header);
  }
 },
 
 // รีเซ็ต ScrollManager
 reset() {
  const { header } = elements;
  if (header) {
   header.getAnimations().forEach(animation => animation.cancel());
   header.style.transform = 'translateY(0)';
  }
 }
};

const ButtonManager = {
    // สถานะภายใน
    state: {
        currentMainButton: null,
        currentSubButton: null,
        isInitialized: false,
        cache: new Map(),
        lastUpdate: '2025-04-17 00:08:27',
        currentUser: 'Jeffy2600-4'
    },

    // โหลดการตั้งค่าปุ่ม
    async loadConfig() {
        try {
            if (state.buttonConfig) {
                await this.renderMainButtons();
                return;
            }

            const cached = DataManager.getCached('buttonConfig');
            if (cached) {
                state.buttonConfig = cached;
                await this.renderMainButtons();
                return;
            }

            const response = await DataManager.fetchWithRetry('/assets/json/buttons.min.json');
            state.buttonConfig = response;
            DataManager.setCache('buttonConfig', response);

            await this.renderMainButtons();
            await NavigationManager.updateButtonStates();

        } catch (error) {
            console.error('Error loading button config:', error);
            utils.showNotification('ไม่สามารถโหลดการตั้งค่าปุ่มได้', 'error');
            throw new AppError('ไม่สามารถโหลดการตั้งค่าปุ่มได้', 'config', error);
        }
    },

    // เรนเดอร์ปุ่มหลัก
    async renderMainButtons() {
        const lang = localStorage.getItem('selectedLang') || 'en';
        const { mainButtons } = state.buttonConfig;
        const { navList } = elements;

        // เคลียร์ปุ่มเดิม
        navList.innerHTML = '';
        this.state.buttonMap = new Map();

        // สร้างและเรนเดอร์ปุ่มใหม่
        let defaultButton = null;

        for (const button of mainButtons) {
            const label = button[`${lang}_label`];
            if (!label) continue;

            const li = document.createElement('li');
            const mainButton = document.createElement('button');
            
            // ตั้งค่าปุ่ม
            mainButton.textContent = label;
            mainButton.className = 'main-button';
            const buttonUrl = button.url || button.jsonFile;
            mainButton.setAttribute('data-url', buttonUrl);
            
            if (button.className) {
                mainButton.classList.add(button.className);
            }

            // เก็บข้อมูลปุ่ม
            this.state.buttonMap.set(buttonUrl, {
                button: mainButton,
                config: button,
                element: mainButton
            });

            if (button.isDefault) {
                defaultButton = {
                    button: mainButton,
                    config: button
                };
            }

            // เพิ่ม event listener
            mainButton.addEventListener('click', async (event) => {
                try {
                    event.preventDefault();
                    
                    // เก็บค่าปุ่มหลักก่อนหน้า
                    NavigationManager.state.previousMainRoute = NavigationManager.state.currentMainRoute;

                    // ล้างเนื้อหาเดิม
                    await ContentManager.clearContent();

                    // จัดการการนำทาง
                    const skipUrlUpdate = !!button.subButtons;
                    if (!button.subButtons && button.url) {
                        await NavigationManager.navigateTo(button.url, { skipUrlUpdate });
                    }

                    // โหลดเนื้อหาใหม่
                    if (button.jsonFile) {
                        try {
                            const data = await DataManager.fetchWithRetry(button.jsonFile);
                            await ContentManager.renderContent(data);
                        } catch (error) {
                            console.error('Error loading content:', error);
                            utils.showNotification('ไม่สามารถโหลดเนื้อหาได้', 'error');
                            return;
                        }
                    }

                    // อัพเดทสถานะ
                    NavigationManager.state.currentMainRoute = buttonUrl;
                    this.state.currentMainButton = mainButton;

                    // จัดการปุ่มย่อย
                    if (button.subButtons) {
                        await this.renderSubButtons(button.subButtons, buttonUrl, lang);
                    }

                } catch (error) {
                    console.error('Error handling button click:', error);
                    utils.showNotification(error.message, 'error');
                }
            });

            li.appendChild(mainButton);
            navList.appendChild(li);
        }

        // จัดการ URL เริ่มต้น
        const initialUrl = window.location.hash.replace('#', '');
        await this.handleInitialUrl(initialUrl, this.state.buttonMap, defaultButton);
    },

    // จัดการ URL เริ่มต้น
    async handleInitialUrl(url, buttonMap, defaultButton) {
        try {
            if (!url) {
                if (defaultButton) {
                    await this.triggerButtonClick(defaultButton.button);
                }
                return;
            }

            const [mainRoute, subRoute] = url.split('-');
            const mainButtonData = buttonMap.get(mainRoute);

            if (!mainButtonData) {
                console.warn('ไม่พบปุ่มหลักสำหรับ URL:', url);
                if (defaultButton) {
                    await this.triggerButtonClick(defaultButton.button);
                }
                return;
            }

            const { button: mainButton, config: mainConfig } = mainButtonData;

            try {
                // ตรวจสอบความถูกต้องของ URL
                const isValidUrl = await NavigationManager.validateUrl(url);
                if (!isValidUrl) {
                    throw new Error('URL ไม่ถูกต้อง');
                }

                // แสดง loading
                const loadingNotification = utils.showNotification('กำลังโหลดเนื้อหา...', 'loading', { 
                    duration: Infinity,
                    dismissible: false 
                });

                try {
                    // อัพเดทสถานะการนำทาง
                    NavigationManager.state.currentMainRoute = mainRoute;
                    NavigationManager.state.currentSubRoute = subRoute || '';
                    this.state.currentMainButton = mainButton;

                    // ทำ active และอัพเดทสถานะปุ่มหลัก
                    await this.activateMainButton(mainButton, mainConfig);

                    // จัดการปุ่มย่อย
                    if (subRoute && mainConfig.subButtons) {
                        await this.handleInitialSubRoute(mainConfig, mainRoute, subRoute);
                    } else if (!subRoute && mainConfig.subButtons) {
                        await this.handleDefaultSubButton(mainConfig, mainRoute);
                    }

                    // เลื่อนปุ่มที่ active ให้เห็น
                    await NavigationManager.scrollActiveButtonsIntoView();

                } finally {
                    // ซ่อน loading
                    if (loadingNotification) {
                        loadingNotification.remove();
                    }
                }

            } catch (error) {
                console.error('เกิดข้อผิดพลาดในการจัดการ URL เริ่มต้น:', error);
                utils.showNotification(`ไม่สามารถโหลดหน้าที่ต้องการได้: ${error.message}`, 'error');
                
                if (defaultButton) {
                    await this.triggerButtonClick(defaultButton.button);
                }
            }

        } catch (error) {
            console.error('เกิดข้อผิดพลาดร้ายแรง:', error);
            utils.showNotification('เกิดข้อผิดพลาดในการโหลดหน้า กรุณาลองใหม่', 'error');
            
            if (defaultButton) {
                await this.triggerButtonClick(defaultButton.button);
            }
        }
    },

    // จัดการปุ่มหลัก
    async activateMainButton(mainButton, mainConfig) {
        try {
            // ล้าง active state ของปุ่มหลักทั้งหมด
            elements.navList.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('active');
            });

            // เพิ่ม active state ให้ปุ่มหลัก
            mainButton.classList.add('active');
            this.state.currentMainButton = mainButton;

            // โหลดเนื้อหา
            if (mainConfig.jsonFile) {
                await ContentManager.clearContent();
                const mainData = await DataManager.fetchWithRetry(mainConfig.jsonFile);
                await ContentManager.renderContent(mainData);
            }

        } catch (error) {
            console.error('Error activating main button:', error);
            throw error;
        }
    },

    // จัดการปุ่มย่อยเริ่มต้น
    async handleInitialSubRoute(mainConfig, mainRoute, subRoute) {
        try {
            // รอให้ DOM อัพเดท
            await new Promise(resolve => setTimeout(resolve, 100));

            // เรนเดอร์ปุ่มย่อย
            const lang = localStorage.getItem('selectedLang') || 'en';
            await this.renderSubButtons(mainConfig.subButtons, mainRoute, lang);

            // หาและ active ปุ่มย่อย
            const subButton = document.querySelector(`button[data-url="${mainRoute}-${subRoute}"]`);
            const subButtonConfig = mainConfig.subButtons.find(
                btn => btn.url === subRoute || btn.jsonFile === subRoute
            );

            if (subButton && subButtonConfig) {
                // ล้างและเพิ่ม active state
                elements.subButtonsContainer.querySelectorAll('.button-sub').forEach(btn => {
                    btn.classList.remove('active');
                });
                subButton.classList.add('active');
                this.state.currentSubButton = subButton;

                // โหลดเนื้อหา
                if (subButtonConfig.jsonFile) {
                    await ContentManager.clearContent();
                    const subData = await DataManager.fetchWithRetry(subButtonConfig.jsonFile);
                    await ContentManager.renderContent(subData);
                }

                // เลื่อนปุ่มให้เห็น
                this.scrollActiveSubButtonIntoView(subButton);
            }

        } catch (error) {
            console.error('Error handling initial sub-route:', error);
            throw error;
        }
    },

    // จัดการปุ่มย่อย default
    async handleDefaultSubButton(mainConfig, mainRoute) {
        try {
            const defaultSubButton = mainConfig.subButtons.find(btn => btn.isDefault);
            if (defaultSubButton) {
                const fullUrl = `${mainRoute}-${defaultSubButton.url || defaultSubButton.jsonFile}`;
                await NavigationManager.navigateTo(fullUrl, { skipUrlUpdate: false });
            }
        } catch (error) {
            console.error('Error handling default sub-button:', error);
            throw error;
        }
    },

    // Trigger การคลิกปุ่ม
    async triggerButtonClick(button, options = {}) {
        if (!button) {
            throw new Error('ไม่พบปุ่มที่จะคลิก');
        }

        try {
            const buttonUrl = button.getAttribute('data-url');
            const isSubButton = button.classList.contains('sub-button');
            const buttonConfig = isSubButton ? 
                this.findSubButtonConfig(buttonUrl) :
                this.findMainButtonConfig(buttonUrl);

            // เรียกใช้ event listener
            await this.handleButtonClick(button, buttonConfig, isSubButton);
            
            // อัพเดทสถานะ
            if (isSubButton) {
                this.state.currentSubButton = button;
            } else {
                this.state.currentMainButton = button;
            }
            
            // อัพเดท active state
            this.updateButtonState(button, isSubButton);

        } catch (error) {
            console.error('Error triggering button click:', error);
            throw new Error(`เกิดข้อผิดพลาดในการคลิกปุ่ม: ${error.message}`);
        }
    },

    // จัดการการคลิกปุ่ม
    async handleButtonClick(button, buttonConfig, isSubButton) {
        try {
            // ล้างเนื้อหาเดิม
            await ContentManager.clearContent();

            // โหลดเนื้อหาใหม่
            if (buttonConfig?.jsonFile) {
                const data = await DataManager.fetchWithRetry(buttonConfig.jsonFile);
                await ContentManager.renderContent(data);
            }

            // ส่ง click event
            const clickEvent = new MouseEvent('click', {
                bubbles: true,
                cancelable: true,
                view: window
            });
            button.dispatchEvent(clickEvent);

        } catch (error) {
            console.error('Error handling button click:', error);
            utils.showNotification('ไม่สามารถโหลดเนื้อหาได้', 'error');
            throw error;
        }
    },

    // ค้นหา config ของปุ่มหลัก
    findMainButtonConfig(url) {
        return state.buttonConfig?.mainButtons?.find(
            btn => btn.url === url || btn.jsonFile === url
        );
    },

    // ค้นหา config ของปุ่มย่อย
    findSubButtonConfig(fullUrl) {
        const [mainRoute, subRoute] = fullUrl.split('-');
        const mainButton = this.findMainButtonConfig(mainRoute);
        
        return mainButton?.subButtons?.find(
            btn => btn.url === subRoute || btn.jsonFile === subRoute
        );
    },

    // อัพเดทสถานะปุ่ม
    updateButtonState(button, isSubButton) {
        try {
            // ล้างสถานะปุ่มทั้งหมดในกลุ่มเดียวกัน
            const buttonGroup = isSubButton ? 
                elements.subButtonsContainer :
                elements.navList;
            
            if (!buttonGroup) {
                console.warn('ไม่พบ button group element');
                return;
            }

            // ล้าง active state
            buttonGroup.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('active');
            });

            // เพิ่ม active state
            if (button && button instanceof HTMLElement) {
                button.classList.add('active');
                
                // อัพเดทสถานะปัจจุบัน
                if (isSubButton) {
                    this.state.currentSubButton = button;
                    this.scrollActiveSubButtonIntoView(button);
                } else {
                    this.state.currentMainButton = button;
                }
            }

        } catch (error) {
            console.error('Error updating button state:', error);
        }
    },

    // เรนเดอร์ปุ่มย่อย
    async renderSubButtons(subButtons, mainButtonUrl, lang) {
        const { subButtonsContainer } = elements;

        subButtonsContainer.innerHTML = '';
        subButtonsContainer.classList.add('fade-out');

        await new Promise(resolve => setTimeout(resolve, 100));

        let defaultSubButton = null;
        const currentHash = window.location.hash.replace('#', '');

        subButtons.forEach(button => {
            const label = button[`${lang}_label`];
            if (!label) return;

            const subButton = document.createElement('button');
            subButton.className = 'button-sub sub-button';
            if (button.className) {
                subButton.classList.add(button.className);
            }
            subButton.textContent = label;

            const fullUrl = button.url ?
                `${mainButtonUrl}-${button.url}` :
                `${mainButtonUrl}-${button.jsonFile}`;

            subButton.setAttribute('data-url', fullUrl);

            if (button.isDefault) {
                defaultSubButton = subButton;
            }

            subButton.addEventListener('click', async () => {
                try {
                    // อัพเดทสถานะ active
                    this.updateButtonState(subButton, true);

                    // นำทางและโหลดเนื้อหา
                    await Promise.all([
                        NavigationManager.navigateTo(fullUrl),
                        button.jsonFile ? (async () => {
                            const data = await DataManager.fetchWithRetry(button.jsonFile);
                            await ContentManager.renderContent(data);
                        })() : Promise.resolve()
                    ]);

                } catch (error) {
                    console.error('Error handling sub-button click:', error);
                    utils.showNotification(error.message, 'error');
                }
            });

            subButtonsContainer.appendChild(subButton);

            // ตรวจสอบ active state
            if (fullUrl === currentHash) {
                this.updateButtonState(subButton, true);
            }
        });

        // จัดการปุ่ม default
        const needsDefault = !currentHash ||
            !subButtonsContainer.querySelector('.button-sub.active');

        if (needsDefault && defaultSubButton) {
            await this.triggerButtonClick(defaultSubButton);
        }

        subButtonsContainer.classList.remove('fade-out');
        subButtonsContainer.classList.add('fade-in');
    },

    // เลื่อนปุ่มให้เห็น
    scrollActiveSubButtonIntoView(activeButton) {
        if (!activeButton || !elements.subButtonsContainer) return;

        requestAnimationFrame(() => {
            const container = elements.subButtonsContainer;
            const containerLeft = container.getBoundingClientRect().left;
            const buttonLeft = activeButton.getBoundingClientRect().left;
            const scrollLeft = container.scrollLeft;

            const targetScroll = scrollLeft + (buttonLeft - containerLeft) - 20;

            if (Math.abs(container.scrollLeft - targetScroll) > 1) {
                container.scrollTo({
                    left: targetScroll,
                    behavior: 'smooth'
                });
            }
        });
    },

    // อัพเดทภาษาของปุ่ม
    updateButtonsLanguage(newLang) {
        try {
            const { mainButtons } = state.buttonConfig;
            const { navList, subButtonsContainer } = elements;

            // อัพเดทปุ่มหลัก
            navList.querySelectorAll('button').forEach((button, index) => {
                const config = mainButtons[index];
                if (config && config[`${newLang}_label`]) {
                    button.textContent = config[`${newLang}_label`];
                }
            });

            // อัพเดทปุ่มย่อย
            if (this.state.currentMainButton) {
                const mainConfig = this.findMainButtonConfig(
                    this.state.currentMainButton.getAttribute('data-url')
                );

                if (mainConfig?.subButtons) {
                    this.renderSubButtons(
                        mainConfig.subButtons,
                        mainConfig.url || mainConfig.jsonFile,
                        newLang
                    );
                }
            }

        } catch (error) {
            console.error('Error updating buttons language:', error);
            utils.showNotification('ไม่สามารถอัพเดทภาษาของปุ่มได้', 'error');
        }
    },

    // รีเซ็ตสถานะทั้งหมด
    reset() {
        this.state = {
            currentMainButton: null,
            currentSubButton: null,
            isInitialized: false,
            cache: new Map(),
            lastUpdate: '2025-04-17 00:08:27',
            currentUser: 'Jeffy2600-4'
        };
        
        // ล้าง active state ทั้งหมด
        elements.navList?.querySelectorAll('button').forEach(btn => {
            btn.classList.remove('active');
        });
        elements.subButtonsContainer?.querySelectorAll('button').forEach(btn => {
            btn.classList.remove('active');
        });
    }
};

    // Performance Optimizations
    const PerformanceOptimizer = {
     init() {
      this.setupLazyLoading();
      this.setupPrefetching();
      this.setupErrorBoundary();
     },
     
     setupLazyLoading() {
      if ('loading' in HTMLImageElement.prototype) {
       document.querySelectorAll('img').forEach(img => {
        img.loading = 'lazy';
       });
      } else {
       this.setupIntersectionObserver();
      }
     },
     
     setupIntersectionObserver() {
      const imageObserver = new IntersectionObserver((entries, observer) => {
       entries.forEach(entry => {
        if (entry.isIntersecting) {
         const img = entry.target;
         if (img.dataset.src) {
          img.src = img.dataset.src;
          img.removeAttribute('data-src');
         }
         observer.unobserve(img);
        }
       });
      });
      
      document.querySelectorAll('img[data-src]').forEach(img => {
       imageObserver.observe(img);
      });
     },
     
     setupPrefetching() {
      const prefetchLinks = new Set();
      
      document.querySelectorAll('a[href], button[data-url]').forEach(element => {
       const url = element.href || element.dataset.url;
       if (url && !prefetchLinks.has(url)) {
        const link = document.createElement('link');
        link.rel = 'prefetch';
        link.href = url;
        link.as = url.endsWith('.json') ? 'fetch' : 'document';
        document.head.appendChild(link);
        prefetchLinks.add(url);
       }
      });
     },
     
     setupErrorBoundary() {
      window.addEventListener('error', event => {
       console.error('Global error:', event.error);
       utils.showNotification(
        'เกิดข้อผิดพลาดที่ไม่คาดคิด กรุณาลองใหม่อีกครั้ง',
        'error'
       );
      });
      
      window.addEventListener('unhandledrejection', event => {
       console.error('Unhandled promise rejection:', event.reason);
       utils.showNotification(
        'เกิดข้อผิดพลาดในการเชื่อมต่อ กรุณาตรวจสอบการเชื่อมต่ออินเทอร์เน็ต',
        'error'
       );
      });
     }
    };
    
const initializeApp = async () => {
    // สถานะการทำงานของแอพ
    const appState = {
        isInitialized: false,
        lastError: null,
        startTime: Date.now(),
        currentUser: 'Jeffy2600III' // รับค่าจาก current user
    };

    try {
        // 1. ตรวจสอบ elements ที่จำเป็นก่อนเริ่มต้น
        if (!NavigationManager.validateElements()) {
            throw new Error('ไม่พบ elements ที่จำเป็นบางส่วน กรุณาตรวจสอบโครงสร้าง HTML');
        }

        // 2. เริ่มต้นระบบจัดการข้อผิดพลาด
        const setupErrorHandling = () => {
            // จัดการข้อผิดพลาดทั่วไป
            window.addEventListener('error', (event) => {
                console.error('เกิดข้อผิดพลาดทั่วไป:', event.error);
                appState.lastError = event.error;
                utils.showNotification(
                    'เกิดข้อผิดพลาดบางอย่าง กรุณารีเฟรชหน้าเว็บ',
                    'error',
                    { duration: 5000 }
                );
            });

            // จัดการ Promise ที่ไม่ได้จัดการข้อผิดพลาด
            window.addEventListener('unhandledrejection', (event) => {
                console.error('พบ Promise ที่ไม่ได้จัดการข้อผิดพลาด:', event.reason);
                appState.lastError = event.reason;
                utils.showNotification(
                    'เกิดข้อผิดพลาดในการเชื่อมต่อ กรุณาลองใหม่อีกครั้ง',
                    'error',
                    { duration: 5000 }
                );
            });
        };

        // 3. เริ่มต้นระบบต่างๆ
        // เริ่มต้นระบบจัดการการเลื่อน
        ScrollManager.init();
        
        // เริ่มต้นระบบเพิ่มประสิทธิภาพ
        PerformanceOptimizer.init();

        // 4. ตั้งค่า Event Listeners สำหรับปุ่มนำทาง
        const setupNavigationButtons = () => {
            elements.navButtons.forEach(button => {
                button.addEventListener('click', async (event) => {
                    event.preventDefault();
                    const route = button.getAttribute('data-url');
                    if (route) {
                        try {
                            await NavigationManager.navigateTo(route);
                        } catch (error) {
                            utils.showNotification(
                                'เกิดข้อผิดพลาดในการนำทาง กรุณาลองใหม่',
                                'error'
                            );
                            console.error('ข้อผิดพลาดการนำทาง:', error);
                        }
                    }
                });
            });
        };

        // 5. ตั้งค่าการติดตามสถานะเครือข่าย
        const setupNetworkMonitoring = () => {
            window.addEventListener('online', () => {
                utils.showNotification('การเชื่อมต่อกลับมาแล้ว', 'success');
                // ลองโหลดข้อมูลที่ไม่สำเร็จใหม่
                if (appState.lastError) {
                    ButtonManager.loadConfig();
                }
            });

            window.addEventListener('offline', () => {
                utils.showNotification('ขาดการเชื่อมต่ออินเทอร์เน็ต', 'warning');
            });
        };

        // 6. ตั้งค่าการจัดการ URL
const setupUrlHandling = () => {
// ฟังก์ชันปรับปรุงสำหรับการจัดการเหตุการณ์ popstate เพื่อให้การนำทางย้อนกลับทำงานเหมือนกับการคลิกปุ่มนำทางทุกครั้ง
window.addEventListener('popstate', async (event) => {
    try {
        // ดึง hash ที่อยู่ใน URL หลัง '#' มาใช้งาน
        const currentHash = window.location.hash.replace('#', '');
        if (!currentHash) return; // ถ้าไม่มี hash ให้ข้ามการนำทาง

        // เรียกใช้ NavigationManager.navigateTo ด้วย currentHash 
        // โดยระบุ options.skipUrlUpdate เป็น true เพื่อไม่ให้เปลี่ยน URL ซ้ำ
        // แต่กระบวนการดึงข้อมูลจะเหมือนกับการคลิกปุ่มนำทางทุกครั้ง
        await NavigationManager.navigateTo(currentHash, { skipUrlUpdate: true });
    } catch (error) {
        console.error('เกิดข้อผิดพลาดในการจัดการการนำทางย้อนกลับ:', error);
        utils.showNotification('เกิดข้อผิดพลาดในการนำทางย้อนกลับ กรุณาลองใหม่', 'error');
    }
});
 
 // จัดการการเปลี่ยนแปลง hash แยกต่างหาก
 window.addEventListener('hashchange', async (event) => {
  if (!NavigationManager.state.isNavigating) {
   const newHash = event.newURL.split('#')[1] || '';
   await NavigationManager.navigateTo(newHash);
  }
 });
};

        // 7. ตั้งค่าการจัดการการเปลี่ยนภาษา
        const setupLanguageHandling = () => {
            window.addEventListener('languageChange', (event) => {
                const newLang = event.detail.language;
                ButtonManager.updateButtonsLanguage(newLang);
                ContentManager.updateCardsLanguage(newLang);
            });
        };

        // 8. ตั้งค่าการจัดการการ resize หน้าจอ
        const setupResizeHandling = () => {
            let resizeTimeout;
            window.addEventListener('resize', () => {
                // ใช้ debounce เพื่อไม่ให้เรียกฟังก์ชันบ่อยเกินไป
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    NavigationManager.scrollActiveButtonsIntoView();
                }, 150);
            });
        };

        // 9. เริ่มต้นการทำงานของระบบต่างๆ
        setupErrorHandling();
        setupNavigationButtons();
        setupNetworkMonitoring();
        setupUrlHandling();
        setupLanguageHandling();
        setupResizeHandling();

        // 10. โหลดการตั้งค่าปุ่มเริ่มต้น
        await ButtonManager.loadConfig();

        // 11. ทำเครื่องหมายว่าแอพเริ่มต้นเรียบร้อยแล้ว
        appState.isInitialized = true;
        console.log('แอพพลิเคชันเริ่มต้นเรียบร้อยแล้ว:', {
            startupTime: Date.now() - appState.startTime + 'ms',
            currentUser: appState.currentUser
        });

    } catch (error) {
        // จัดการข้อผิดพลาดที่เกิดขึ้นระหว่างการเริ่มต้นแอพ
        console.error('เกิดข้อผิดพลาดในการเริ่มต้นแอพพลิเคชัน:', error);
        appState.lastError = error;
        utils.showNotification(
            'เกิดข้อผิดพลาดในการโหลดแอพพลิเคชัน กรุณารีเฟรชหน้าเว็บ',
            'error',
            { 
                duration: 5000,
                dismissible: true
            }
        );

        // พยายามกู้คืนส่วนที่สำคัญ
        try {
            setupErrorHandling();
            setupNetworkMonitoring();
        } catch (recoveryError) {
            console.error('ไม่สามารถกู้คืนระบบพื้นฐานได้:', recoveryError);
        }
    }
};

// เริ่มต้นแอพพลิเคชันเมื่อ DOM พร้อม
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    initializeApp();
}
    });