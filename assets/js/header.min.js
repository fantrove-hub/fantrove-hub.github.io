/**
 * header.js - Enhanced version (แก้ไขปัญหาการนำทางและ URL)
 */
document.addEventListener('DOMContentLoaded', () => {
    // ประกาศตัวแปรสำหรับใช้ทั้งไฟล์
    const state = {
        isRendering: false,
        debounceTimer: null,
        buttonConfig: null,
        cache: new Map(),
        navigationState: {
            isNavigating: false,
            currentMainRoute: '',
            currentSubRoute: '',
            isInitialLoad: true,
            previousUrl: ''
        }
    };

    // Element selectors
    const elements = {
        header: document.querySelector('header'),
        navButtons: document.querySelectorAll('nav ul li button'),
        logo: document.querySelector('.logo'),
        navList: document.getElementById('nav-list'),
        subButtonsContainer: document.getElementById('sub-buttons-container')
    };

    // Constants
    const CONSTANTS = {
        ANIMATION_DURATION: 500,
        SCROLL_THRESHOLD: 1.27,
        CACHE_DURATION: 5 * 60 * 1000, // 5 minutes
        FETCH_TIMEOUT: 5000,
        RETRY_DELAY: 2000,
        MAX_RETRIES: 3
    };

// ระบบจัดการข้อผิดพลาดที่ปรับปรุงใหม่
class ErrorManager {
  constructor() {
    this.errorStates = new Map();
    this.timeouts = new Map();
  }

  // ตรวจสอบความถูกต้องของข้อผิดพลาด
  isValidError(error) {
    return error && (
      error instanceof Error ||
      error.message ||
      typeof error === 'string'
    );
  }

  // ตรวจสอบว่าเป็นข้อผิดพลาดเดิมหรือไม่
  isDuplicateError(errorKey, message) {
    const existingError = this.errorStates.get(errorKey);
    return existingError && existingError.message === message;
  }

  // จัดการแสดงข้อผิดพลาด
  showError(errorKey, error, options = {}) {
    if (!this.isValidError(error)) return;

    const message = error.message || error.toString();
    
    // ถ้าเป็นข้อผิดพลาดเดิม ไม่ต้องแสดงซ้ำ
    if (this.isDuplicateError(errorKey, message)) return;

    // เคลียร์ timeout เดิมถ้ามี
    if (this.timeouts.has(errorKey)) {
      clearTimeout(this.timeouts.get(errorKey));
    }

    // บันทึกสถานะข้อผิดพลาด
    this.errorStates.set(errorKey, {
      message,
      timestamp: Date.now(),
      type: options.type || 'error'
    });

    // แสดงข้อผิดพลาด
    utils.showNotification(message, options.type || 'error', {
      duration: options.duration || 3000,
      position: options.position || 'top',
      dismissible: options.dismissible !== false
    });

    // ตั้งเวลาลบสถานะข้อผิดพลาด
    const timeout = setTimeout(() => {
      this.errorStates.delete(errorKey);
      this.timeouts.delete(errorKey);
    }, options.duration || 3000);

    this.timeouts.set(errorKey, timeout);
  }

  // เคลียร์ข้อผิดพลาดทั้งหมด
  clearErrors() {
    this.errorStates.clear();
    this.timeouts.forEach(clearTimeout);
    this.timeouts.clear();
  }
}

// สร้าง instance เดียวสำหรับใช้ทั้งระบบ
const errorManager = new ErrorManager();

const utils = {
  // ตัวแปรสำหรับเก็บค่าคงที่
  CONSTANTS: {
    ANIMATION_DURATION: 300,
    NOTIFICATION_DURATION: 3000,
    DEBOUNCE_DELAY: 250,
    THROTTLE_DELAY: 100,
    MAX_CACHE_SIZE: 100,
    MAX_RETRIES: 3
  },

  // Cache system
  cache: new Map(),
  
  // สำหรับเก็บ notification ที่กำลังแสดงอยู่
  activeNotifications: new Set(),

  /**
   * แสดง notification
   * @param {string} message - ข้อความที่จะแสดง
   * @param {string} type - ประเภทของ notification (success, error, warning, info, loading)
   * @param {Object} options - ตัวเลือกเพิ่มเติม
   * @returns {HTMLElement} - Element ของ notification
   */
  showNotification(message, type = 'info', options = {}) {
    const {
      duration = this.CONSTANTS.NOTIFICATION_DURATION,
      position = 'top-right',
      dismissible = true,
      icon = true,
      progress = true,
      maxWidth = '400px',
      animationDuration = 300
    } = options;

    // ตรวจสอบ notification ซ้ำ
    const notificationKey = `${message}-${type}`;
    if (this.activeNotifications.has(notificationKey)) {
      return;
    }

    // สร้าง notification container
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.setAttribute('data-key', notificationKey);
    notification.style.maxWidth = maxWidth;

    // กำหนด style ตาม position
    this.setNotificationPosition(notification, position);

    // สร้างโครงสร้างภายใน notification
    const content = this.createNotificationContent(message, type, icon);
    notification.appendChild(content);

    // เพิ่มปุ่มปิดถ้า dismissible เป็น true
    if (dismissible) {
      const closeButton = this.createCloseButton(() => this.removeNotification(notification, notificationKey));
      notification.appendChild(closeButton);
    }

    // เพิ่ม progress bar ถ้าต้องการ
    if (progress && duration !== Infinity) {
      const progressBar = this.createProgressBar(duration);
      notification.appendChild(progressBar);
    }

    // เพิ่ม notification เข้าไปใน DOM
    document.body.appendChild(notification);
    this.activeNotifications.add(notificationKey);

    // เพิ่ม animation
    requestAnimationFrame(() => {
      notification.style.opacity = '0';
      notification.style.transform = 'translateY(-20px)';
      
      requestAnimationFrame(() => {
        notification.style.transition = `all ${animationDuration}ms ease`;
        notification.style.opacity = '1';
        notification.style.transform = 'translateY(0)';
      });
    });

    // ตั้งเวลาลบ notification
    if (duration !== Infinity) {
      setTimeout(() => {
        this.removeNotification(notification, notificationKey);
      }, duration);
    }

    return notification;
  },

  /**
   * ลบ notification
   * @param {HTMLElement} notification - Element ของ notification
   * @param {string} key - Key ของ notification
   */
  removeNotification(notification, key) {
    if (!document.body.contains(notification)) return;

    notification.style.opacity = '0';
    notification.style.transform = 'translateY(-20px)';

    setTimeout(() => {
      if (document.body.contains(notification)) {
        document.body.removeChild(notification);
        this.activeNotifications.delete(key);
      }
    }, 300);
  },

  /**
   * สร้างเนื้อหาภายใน notification
   * @param {string} message - ข้อความ
   * @param {string} type - ประเภท
   * @param {boolean} showIcon - แสดงไอคอนหรือไม่
   * @returns {HTMLElement}
   */
  createNotificationContent(message, type, showIcon) {
    const content = document.createElement('div');
    content.className = 'notification-content';

    if (showIcon) {
      const icon = this.createIcon(type);
      content.appendChild(icon);
    }

    const messageElement = document.createElement('span');
    messageElement.className = 'notification-message';
    messageElement.textContent = message;
    content.appendChild(messageElement);

    return content;
  },

  /**
   * สร้างปุ่มปิด notification
   * @param {Function} onClose - ฟังก์ชันที่จะทำงานเมื่อกดปิด
   * @returns {HTMLElement}
   */
  createCloseButton(onClose) {
    const closeButton = document.createElement('button');
    closeButton.className = 'notification-close';
    closeButton.innerHTML = '×';
    closeButton.onclick = onClose;
    return closeButton;
  },

  /**
   * สร้าง progress bar
   * @param {number} duration - ระยะเวลา
   * @returns {HTMLElement}
   */
  createProgressBar(duration) {
    const progress = document.createElement('div');
    progress.className = 'notification-progress';
    progress.style.animation = `notification-progress ${duration}ms linear`;
    return progress;
  },

  /**
   * สร้างไอคอน
   * @param {string} type - ประเภทของไอคอน
   * @returns {HTMLElement}
   */
  createIcon(type) {
    const icon = document.createElement('span');
    icon.className = 'notification-icon';
    
    const iconContent = {
      success: '✓',
      error: '✕',
      warning: '⚠',
      info: 'ℹ',
      loading: '↻'
    };

    icon.textContent = iconContent[type] || 'ℹ';
    if (type === 'loading') {
      icon.style.animation = 'spin 1s linear infinite';
    }
    
    return icon;
  },

  /**
   * กำหนดตำแหน่งของ notification
   * @param {HTMLElement} notification - Element ของ notification
   * @param {string} position - ตำแหน่งที่ต้องการ
   */
  setNotificationPosition(notification, position) {
    const positions = {
      'top-right': { top: '20px', right: '20px' },
      'top-left': { top: '20px', left: '20px' },
      'bottom-right': { bottom: '20px', right: '20px' },
      'bottom-left': { bottom: '20px', left: '20px' },
      'top-center': { top: '20px', left: '50%', transform: 'translateX(-50%)' },
      'bottom-center': { bottom: '20px', left: '50%', transform: 'translateX(-50%)' }
    };

    const pos = positions[position] || positions['top-right'];
    Object.assign(notification.style, pos);
  },

  /**
   * Debounce function
   * @param {Function} func - ฟังก์ชันที่ต้องการ debounce
   * @param {number} wait - ระยะเวลารอ
   * @returns {Function}
   */
  debounce(func, wait = this.CONSTANTS.DEBOUNCE_DELAY) {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  },

  /**
   * Throttle function
   * @param {Function} func - ฟังก์ชันที่ต้องการ throttle
   * @param {number} limit - ระยะเวลาจำกัด
   * @returns {Function}
   */
  throttle(func, limit = this.CONSTANTS.THROTTLE_DELAY) {
    let inThrottle;
    return (...args) => {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  },

  /**
   * คัดลอกข้อความไปยัง clipboard
   * @param {string} content - ข้อความที่ต้องการคัดลอก
   * @returns {Promise<void>}
   */
  async copyToClipboard(content) {
    try {
      await navigator.clipboard.writeText(content);
      this.showNotification('คัดลอกข้อความสำเร็จ', 'success', { duration: 2000 });
    } catch (error) {
      this.showNotification('ไม่สามารถคัดลอกข้อความได้', 'error');
      throw new Error('ไม่สามารถคัดลอกข้อความได้');
    }
  },

  /**
   * ตรวจสอบการเชื่อมต่ออินเทอร์เน็ต
   * @returns {boolean}
   */
  isOnline() {
    return navigator.onLine;
  },

  /**
   * เพิ่มข้อมูลลงใน cache
   * @param {string} key - คีย์
   * @param {any} data - ข้อมูล
   * @param {number} expiry - เวลาหมดอายุ (ms)
   */
  setCache(key, data, expiry = 5 * 60 * 1000) {
    if (this.cache.size >= this.CONSTANTS.MAX_CACHE_SIZE) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }

    this.cache.set(key, {
      data,
      expiry: Date.now() + expiry
    });
  },

  /**
   * ดึงข้อมูลจาก cache
   * @param {string} key - คีย์
   * @returns {any|null}
   */
  getCache(key) {
    const cached = this.cache.get(key);
    if (!cached) return null;

    if (Date.now() > cached.expiry) {
      this.cache.delete(key);
      return null;
    }

    return cached.data;
  },

  /**
   * ล้าง cache ทั้งหมด
   */
  clearCache() {
    this.cache.clear();
  }
};

// เพิ่ม CSS สำหรับ notifications
const style = document.createElement('style');
style.textContent = `
  .notification {
    position: fixed;
    padding: 12px;
    margin: 8px;
    border-radius: 4px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    display: flex;
    align-items: center;
    z-index: 9999;
    background: white;
    min-width: 250px;
  }

  .notification-success { background-color: #4caf50; color: white; }
  .notification-error { background-color: #f44336; color: white; }
  .notification-warning { background-color: #ff9800; color: white; }
  .notification-info { background-color: #2196f3; color: white; }
  .notification-loading { background-color: #9e9e9e; color: white; }

  .notification-content {
    flex: 1;
    display: flex;
    align-items: center;
  }

  .notification-icon {
    margin-right: 8px;
    font-size: 18px;
  }

  .notification-message {
    flex: 1;
  }

  .notification-close {
    background: none;
    border: none;
    color: inherit;
    font-size: 20px;
    cursor: pointer;
    padding: 0 4px;
    margin-left: 8px;
  }

  .notification-progress {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 3px;
    background: rgba(255,255,255,0.3);
  }

  @keyframes notification-progress {
    from { width: 100%; }
    to { width: 0%; }
  }

  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }
`;

document.head.appendChild(style);

const NavigationManager = {
    // เก็บประวัติการนำทาง
    history: [],
    maxHistory: 50,
    
    // เพิ่มการจัดการสถานะ
    state: {
        isNavigating: false,
        currentMainRoute: '',
        currentSubRoute: '',
        isInitialLoad: true,
        previousUrl: '',
        lastScrollPosition: 0
    },

    // เพิ่มรายการใหม่ในประวัติ
    addToHistory(url, type = 'user') {
        this.history.unshift({
            url: this.normalizeUrl(url),
            type,
            timestamp: Date.now()
        });
        
        // จำกัดขนาดของประวัติ
        if (this.history.length > this.maxHistory) {
            this.history.pop();
        }
    },

    // ทำความสะอาด URL
    normalizeUrl(url) {
        if (!url) return '';
        return url.toLowerCase().trim().replace(/^#/, '');
    },

    // เปรียบเทียบ URL อย่างแม่นยำ
    compareUrls(url1, url2) {
        return this.normalizeUrl(url1) === this.normalizeUrl(url2);
    },

    // ตรวจสอบความถูกต้องของ URL
    async validateUrl(url) {
        if (!url) return false;
        
        try {
            if (!state.buttonConfig) {
                await ButtonManager.loadConfig();
            }

            const [mainRoute, subRoute] = url.split('-');
            const mainButton = state.buttonConfig.mainButtons.find(
                btn => btn.url === mainRoute || btn.jsonFile === mainRoute
            );

            if (!mainButton) return false;

            // ถ้ามี subRoute ต้องตรวจสอบด้วย
            if (subRoute) {
                if (!mainButton.subButtons) return false;
                return mainButton.subButtons.some(
                    sub => sub.url === subRoute || sub.jsonFile === subRoute
                );
            }

            return true;
        } catch (error) {
            console.error('เกิดข้อผิดพลาดในการตรวจสอบ URL:', error);
            return false;
        }
    },

    // ฟังก์ชันหลักสำหรับการนำทาง
    async navigateTo(route, options = {}) {
        // ตรวจสอบว่ากำลังนำทางอยู่หรือไม่
        if (this.state.isNavigating) {
            console.log('กำลังนำทางอยู่ กรุณารอสักครู่...');
            return;
        }

        try {
            this.state.isNavigating = true;
            this.state.lastScrollPosition = window.pageYOffset;

            // ตรวจสอบว่าเป็น URL ที่ถูกต้องหรือไม่
            const isValidUrl = await this.validateUrl(route);
            if (!isValidUrl) {
                console.log('URL ไม่ถูกต้อง จะใช้ default route แทน');
                route = await this.getDefaultRoute();
            }

            // บันทึกเส้นทางปัจจุบัน
            const [mainRoute, subRoute] = route.split('-');
            this.state.currentMainRoute = mainRoute;
            this.state.currentSubRoute = subRoute || '';

            // อัพเดท URL ถ้าไม่ได้กำหนดให้ข้าม
            if (!options.skipUrlUpdate) {
                await this.changeURL(route);
            }

            // อัพเดทสถานะปุ่ม
            await this.updateButtonStates(route);

            // บันทึกประวัติ
            this.addToHistory(route);

            // จัดการการเลื่อนหน้า
            if (!options.maintainScroll) {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }

        } catch (error) {
            console.error('เกิดข้อผิดพลาดในการนำทาง:', error);
            utils.showNotification('เกิดข้อผิดพลาดในการนำทาง', 'error');
        } finally {
            this.state.isNavigating = false;
        }
    },

    // หา default route
    async getDefaultRoute() {
        try {
            if (!state.buttonConfig) {
                await ButtonManager.loadConfig();
            }
            
            const defaultMainButton = state.buttonConfig.mainButtons.find(btn => btn.isDefault);
            if (!defaultMainButton) return '';

            const mainRoute = defaultMainButton.url || defaultMainButton.jsonFile;
            
            if (!defaultMainButton.subButtons) return mainRoute;

            const defaultSubButton = defaultMainButton.subButtons.find(btn => btn.isDefault);
            if (!defaultSubButton) return mainRoute;

            const subRoute = defaultSubButton.url || defaultSubButton.jsonFile;
            return `${mainRoute}-${subRoute}`;
        } catch (error) {
            console.error('เกิดข้อผิดพลาดในการหา default route:', error);
            return '';
        }
    },

    // เปลี่ยน URL
    async changeURL(url, force = false) {
        try {
            if (!url) return;

            const newUrl = url.includes('#') ? url : `#${url}`;
            
            // ตรวจสอบว่า URL เปลี่ยนไปจริงๆ หรือถูกบังคับให้เปลี่ยน
            if (force || window.location.hash !== newUrl) {
                // ใช้ replaceState แทน pushState เพื่อไม่ให้เกิดการซ้ำซ้อนในประวัติ
                history.replaceState(
                    { 
                        url: newUrl,
                        scrollPosition: this.state.lastScrollPosition
                    },
                    '',
                    newUrl
                );
                
                // เก็บ URL ปัจจุบัน
                this.state.previousUrl = newUrl;

                // แจ้งเตือนการเปลี่ยนแปลง URL
                window.dispatchEvent(new CustomEvent('urlChanged', {
                    detail: { 
                        url: newUrl,
                        mainRoute: this.state.currentMainRoute,
                        subRoute: this.state.currentSubRoute
                    }
                }));
            }
        } catch (error) {
            console.error('เกิดข้อผิดพลาดในการเปลี่ยน URL:', error);
            throw new AppError('ไม่สามารถเปลี่ยน URL ได้', 'navigation', error);
        }
    },

    // อัพเดทสถานะปุ่ม
    async updateButtonStates(route) {
        try {
            const normalizedRoute = this.normalizeUrl(route);
            const [mainRoute, subRoute] = normalizedRoute.split('-');

            // ล้างสถานะปุ่มทั้งหมด
            document.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('active');
            });

            // อัพเดทปุ่มหลัก
            const mainButton = document.querySelector(`button[data-url="${mainRoute}"]`);
            if (mainButton) {
                mainButton.classList.add('active');
            }

            // อัพเดทปุ่มย่อย
            if (subRoute) {
                const subButton = document.querySelector(`button[data-url="${normalizedRoute}"]`);
                if (subButton) {
                    subButton.classList.add('active');
                }
            }

            // เลื่อนปุ่มที่ active เข้ามาในมุมมอง
            this.scrollActiveButtonsIntoView();

        } catch (error) {
            console.error('เกิดข้อผิดพลาดในการอัพเดทสถานะปุ่ม:', error);
        }
    },

    // เลื่อนปุ่มที่ active เข้ามาในมุมมอง
    scrollActiveButtonsIntoView() {
        ['nav ul', '#sub-buttons-container'].forEach(selector => {
            const container = document.querySelector(selector);
            const activeButton = container?.querySelector('button.active');
            
            if (container && activeButton) {
                requestAnimationFrame(() => {
                    const containerBounds = container.getBoundingClientRect();
                    const buttonBounds = activeButton.getBoundingClientRect();
                    
                    const scrollLeft = container.scrollLeft + 
                        (buttonBounds.left - containerBounds.left) - 20;
                    
                    container.scrollTo({
                        left: Math.max(0, scrollLeft),
                        behavior: 'smooth'
                    });
                });
            }
        });
    },

    // จัดการการ refresh
    handleRefresh() {
        const currentHash = window.location.hash.replace('#', '');
        if (currentHash) {
            this.navigateTo(currentHash, { skipUrlUpdate: true });
        } else {
            this.navigateTo(this.getDefaultRoute());
        }
    },

    // รีเซ็ตสถานะทั้งหมด
    reset() {
        this.state = {
            isNavigating: false,
            currentMainRoute: '',
            currentSubRoute: '',
            isInitialLoad: true,
            previousUrl: '',
            lastScrollPosition: 0
        };
        this.history = [];
    }
};

// เพิ่ม Event Listener สำหรับการ resize หน้าจอ
window.addEventListener('resize', () => {
 NavigationManager.scrollActiveButtonToLeft();
});

// เพิ่ม Event Listener สำหรับการโหลดหน้าเว็บครั้งแรก
document.addEventListener('DOMContentLoaded', () => {
 NavigationManager.updateButtonStates();
});

    // Content Management
    const ContentManager = {
        async clearContent() {
            const contentElements = document.querySelectorAll('[id^="content-"]');
            
            await Promise.all(Array.from(contentElements).map(element => {
                return new Promise(resolve => {
                    const handleAnimationEnd = () => {
                        element.innerHTML = '';
                        element.classList.remove('fade-out');
                        element.removeEventListener('animationend', handleAnimationEnd);
                        resolve();
                    };

                    element.addEventListener('animationend', handleAnimationEnd);
                    element.classList.add('fade-out');

                    // Fallback
                    setTimeout(handleAnimationEnd, CONSTANTS.ANIMATION_DURATION);
                });
            }));
        },

        async renderContent(data) {
            if (!Array.isArray(data)) {
                throw new AppError('ข้อมูลที่ได้รับไม่ใช่อาร์เรย์', 'render');
            }

            await this.clearContent();
            if (state.isRendering) return;
            
            state.isRendering = true;
            
            try {
                await Promise.all(data.map(async item => {
                    const targetElement = document.getElementById(item.id);
                    if (!targetElement) return;

                    targetElement.innerHTML = '';
                    const container = this.createContainer(item);
                    
                    if (item.group?.items) {
                        await this.renderGroupItems(container, item.group);
                    } else {
                        await this.renderSingleItem(container, item);
                    }
                    
                    targetElement.appendChild(container);
                }));
            } finally {
                state.isRendering = false;
            }
        },

    createContainer(item) {
     const container = document.createElement('div');
     container.className = item.group?.type === 'button' ?
      'button-content-container' : 'card-content-container';
     
     // เพิ่ม custom class สำหรับ container ถ้ามีการระบุ
     if (item.group?.containerClass) {
      container.classList.add(item.group.containerClass);
     }
     
     return container;
    },

    async renderGroupItems(container, group) {
      // เพิ่มการสร้าง Group Header ถ้ามีการระบุ
      if (group.header) {
       const headerElement = this.createGroupHeader(group.header);
       container.appendChild(headerElement);
      }
      
      const renderPromises = group.items.map(item =>
       group.type === 'button' ?
       this.createButton(item.content) :
       this.createCard(item)
      );
      
      const elements = await Promise.all(renderPromises);
      elements.forEach(element => {
       if (element) container.appendChild(element);
      });
     },
     
// ปรับปรุงโครงสร้างของ Group Header ให้เรียบง่ายขึ้น
createGroupHeader(headerConfig) {
  // สร้าง container หลัก
  const headerContainer = document.createElement('div');
  headerContainer.className = 'group-header';
  
  // รับภาษาปัจจุบัน
  const currentLang = localStorage.getItem('selectedLang') || 'en';
  
  // จัดการกับ headerConfig ที่เป็น string
  if (typeof headerConfig === 'string') {
   return this.createSimpleHeader(headerConfig, headerContainer);
  }
  
  // เพิ่ม custom class ถ้ามี
  if (headerConfig.className) {
   headerContainer.classList.add(headerConfig.className);
  }
  
  // สร้างส่วนประกอบต่างๆ
  this.createHeaderComponents(headerContainer, headerConfig, currentLang);
  
  // เพิ่ม event listener สำหรับการเปลี่ยนภาษา
  this.addLanguageChangeListener(headerContainer, headerConfig);
  
  return headerContainer;
 },
 
 // สร้าง header แบบง่าย
 createSimpleHeader(text, container) {
  const headerText = document.createElement('h2');
  headerText.className = 'group-header-text';
  headerText.textContent = text;
  container.appendChild(headerText);
  return container;
 },
 
 // สร้างส่วนประกอบของ header
 createHeaderComponents(container, config, currentLang) {
  // 1. สร้างไอคอน (ถ้ามี)
  if (config.icon) {
   container.appendChild(this.createHeaderIcon(config.icon));
  }
  
  // 2. สร้างส่วนหัว
  const headerContent = document.createElement('div');
  headerContent.className = 'header-content';
  
  // 2.1 สร้างหัวข้อ
  const title = this.createHeaderTitle(config, currentLang);
  headerContent.appendChild(title);
  
  // 2.2 สร้างคำอธิบาย (ถ้ามี)
  if (config.description) {
   const desc = this.createHeaderDescription(config.description, currentLang);
   headerContent.appendChild(desc);
  }
  
  container.appendChild(headerContent);
  
  // 3. สร้างปุ่มเสริม (ถ้ามี)
  if (config.actions) {
   container.appendChild(this.createHeaderActions(config.actions, currentLang));
  }
 },
 
 // สร้างหัวข้อ
 createHeaderTitle(config, currentLang) {
  const title = document.createElement('h2');
  title.className = 'group-header-text';
  
  // เก็บข้อมูลภาษาใน data attributes
  if (typeof config.title === 'object') {
   Object.entries(config.title).forEach(([lang, text]) => {
    title.dataset[`title${lang.toUpperCase()}`] = text;
   });
   title.textContent = config.title[currentLang] || config.title.en;
  } else {
   title.textContent = config.title;
  }
  
  return title;
 },
 
 // สร้างคำอธิบาย
 createHeaderDescription(description, currentLang) {
  const desc = document.createElement('p');
  desc.className = 'group-header-description';
  
  if (typeof description === 'object') {
   Object.entries(description).forEach(([lang, text]) => {
    desc.dataset[`desc${lang.toUpperCase()}`] = text;
   });
   desc.textContent = description[currentLang] || description.en;
  } else {
   desc.textContent = description;
  }
  
  return desc;
 },
 
 // เพิ่ม event listener สำหรับการเปลี่ยนภาษา
 addLanguageChangeListener(container, config) {
  window.addEventListener('languageChange', (event) => {
   const newLang = event.detail.language;
   this.updateHeaderLanguage(container, config, newLang);
  });
 },

        async renderSingleItem(container, item) {
            const element = item.type === 'button' ? 
                await this.createButton(item.content) : 
                await this.createCard(item);
            
            if (element) container.appendChild(element);
        },

    async createButton(content) {
      const button = document.createElement('button');
      button.className = 'button-content';
      button.textContent = content;
      const wrapper = document.createElement('div');
      wrapper.appendChild(button);
      
      button.addEventListener('click', async () => {
       try {
        await utils.copyToClipboard(content);
       } catch (error) {
        utils.showNotification(error.message, 'error');
       }
      });
      
      return this.animateElement(wrapper);
     },
     
async createCard(cardConfig) {
 const lang = localStorage.getItem('selectedLang') || 'en';
 // สร้าง element สำหรับการ์ดในรูปแบบ <button>
 const card = document.createElement('div');
 card.className = 'card';
 
 // จัดการรูปภาพ (ถ้ามี)
 if (cardConfig.image) {
  const img = document.createElement('img');
  img.className = 'card-image';
  img.src = cardConfig.image;
  img.loading = 'lazy';
  // รองรับ alt text หลายภาษา
  img.alt = cardConfig.imageAlt?.[lang] || cardConfig.imageAlt?.en || '';
  card.appendChild(img);
 }
 
 // สร้าง container สำหรับเนื้อหาการ์ด
 const contentDiv = document.createElement('div');
 contentDiv.className = 'card-content';
 
 // จัดการหัวข้อการ์ด
 const titleDiv = document.createElement('div');
 titleDiv.className = 'card-title';
 if (typeof cardConfig.title === 'object') {
  Object.entries(cardConfig.title).forEach(([langCode, text]) => {
   titleDiv.dataset[`title${langCode.toUpperCase()}`] = text;
  });
  titleDiv.textContent = cardConfig.title[lang] || cardConfig.title.en;
 } else {
  titleDiv.textContent = cardConfig.title;
 }
 contentDiv.appendChild(titleDiv);
 
 // จัดการคำอธิบายของการ์ด
 const descDiv = document.createElement('div');
 descDiv.className = 'card-description';
 if (typeof cardConfig.description === 'object') {
  Object.entries(cardConfig.description).forEach(([langCode, text]) => {
   descDiv.dataset[`desc${langCode.toUpperCase()}`] = text;
  });
  descDiv.textContent = cardConfig.description[lang] || cardConfig.description.en;
 } else {
  descDiv.textContent = cardConfig.description;
 }
 contentDiv.appendChild(descDiv);
 
 // นำ container เนื้อหาการ์ดไปใส่ภายในปุ่มการ์ด
 card.appendChild(contentDiv);
 
 // จัดการลิงก์ให้กับการ์ด (ถ้ามี)
 if (cardConfig.link) {
  card.addEventListener('click', () => {
   window.open(cardConfig.link, '_blank', 'noopener');
  });
 }
 
 // เพิ่มคลาสเพิ่มเติมถ้ามีการกำหนดใน config
 if (cardConfig.className) {
  card.classList.add(cardConfig.className);
 }
 
 // คืนค่า element การ์ดที่ได้หลังจาก animation
 return this.animateElement(card);
},

// เพิ่มในส่วน DataManager หรือ ContentManager
updateCardsLanguage(lang) {
  document.querySelectorAll('.card').forEach(card => {
    // อัพเดทหัวข้อ
    const titleElement = card.querySelector('.card-title');
    if (titleElement) {
      const newTitle = titleElement.dataset[`title${lang.toUpperCase()}`];
      if (newTitle) {
        titleElement.textContent = newTitle;
      }
    }
    
    // อัพเดทคำอธิบาย
    const descElement = card.querySelector('.card-description');
    if (descElement) {
      const newDesc = descElement.dataset[`desc${lang.toUpperCase()}`];
      if (newDesc) {
        descElement.textContent = newDesc;
      }
    }
    
    // อัพเดท alt text ของรูปภาพ
    const imgElement = card.querySelector('.card-image');
    if (imgElement) {
      const newAlt = imgElement.dataset[`alt${lang.toUpperCase()}`];
      if (newAlt) {
        imgElement.alt = newAlt;
      }
    }
  });
},

      
      async animateElement(element) {
       return new Promise(resolve => {
        requestAnimationFrame(() => {
         const handleAnimationEnd = () => {
          element.removeEventListener('animationend', handleAnimationEnd);
          resolve(element);
         };
         
         element.addEventListener('animationend', handleAnimationEnd);
         element.classList.add('fade-in');
         
         // Fallback
         setTimeout(() => handleAnimationEnd(), CONSTANTS.ANIMATION_DURATION);
        });
       });
      }
    };

const DataManager = {
 // ค่าคงที่สำหรับการตั้งค่าต่างๆ
 constants: {
  FETCH_TIMEOUT: 3000, // ระยะเวลา timeout สำหรับการเรียก API (3 วินาที)
  RETRY_DELAY: 1000, // ระยะเวลารอก่อนลองใหม่ (1 วินาที)
  MAX_RETRIES: 2, // จำนวนครั้งสูงสุดที่จะลองใหม่
  CACHE_DURATION: 5 * 60 * 1000, // ระยะเวลาแคช (5 นาที)
  BATCH_SIZE: 10, // ขนาดของชุดข้อมูลในการโหลดแบบแบ่งชุด
 },
 
 // เก็บข้อมูลแคช
 cache: new Map(),
 
 // เก็บสถานะการโหลด
 loadingStates: new Map(),
 
 // ตรวจสอบการเชื่อมต่ออินเทอร์เน็ต
 isOnline() {
  return navigator.onLine;
 },
 
 // เช็คว่าข้อมูลในแคชหมดอายุหรือยัง
 isCacheExpired(timestamp) {
  return Date.now() - timestamp > this.constants.CACHE_DURATION;
 },
 
 // ดึงข้อมูลจากแคช
 getCached(key) {
  const cached = this.cache.get(key);
  if (!cached) return null;
  
  if (this.isCacheExpired(cached.timestamp)) {
   this.cache.delete(key);
   return null;
  }
  
  return cached.data;
 },
 
 // เก็บข้อมูลลงแคช
 setCache(key, data) {
  this.cache.set(key, {
   data,
   timestamp: Date.now()
  });
 },
 
 // ล้างแคชทั้งหมด
 clearCache() {
  this.cache.clear();
 },
 
 // ล้างแคชที่หมดอายุ
 clearExpiredCache() {
  for (const [key, value] of this.cache.entries()) {
   if (this.isCacheExpired(value.timestamp)) {
    this.cache.delete(key);
   }
  }
 },
 
 // สร้าง URL สำหรับการเรียก API
 buildUrl(baseUrl, params = {}) {
  const url = new URL(baseUrl, window.location.origin);
  Object.entries(params).forEach(([key, value]) => {
   if (value !== undefined && value !== null) {
    url.searchParams.append(key, value);
   }
  });
  return url.toString();
 },
 
 // ดึงข้อมูลพร้อม timeout
 async fetchWithTimeout(url, options = {}) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => {
   controller.abort();
   throw new Error('การเชื่อมต่อหมดเวลา กรุณาลองใหม่อีกครั้ง');
  }, this.constants.FETCH_TIMEOUT);
  
  try {
   if (!this.isOnline()) {
    throw new Error('ไม่มีการเชื่อมต่ออินเทอร์เน็ต');
   }
   
   const response = await fetch(url, {
    ...options,
    signal: controller.signal,
    headers: {
     'Content-Type': 'application/json',
     ...options.headers
    }
   });
   
   if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
   }
   
   const data = await response.json();
   
   // ตรวจสอบความถูกต้องของข้อมูล
   if (!data || (Array.isArray(data) && data.length === 0)) {
    throw new Error('ไม่พบข้อมูลที่ต้องการ');
   }
   
   return data;
   
  } finally {
   clearTimeout(timeoutId);
  }
 },
 
 // ดึงข้อมูลพร้อมระบบลองใหม่อัตโนมัติ
 async fetchWithRetry(url, options = {}) {
  const key = `${url}-${JSON.stringify(options)}`;
  
  // เช็คแคชก่อน
  const cachedData = this.getCached(key);
  if (cachedData) {
   return cachedData;
  }
  
  let lastError;
  for (let i = 0; i <= this.constants.MAX_RETRIES; i++) {
   try {
    // แสดงสถานะกำลังโหลด
    LoadingManager.show(key, options.loadingMessage || 'กำลังโหลดข้อมูล...');
    
    const data = await this.fetchWithTimeout(url, options);
    
    // เก็บลงแคชถ้ากำหนดให้แคชได้
    if (options.cache !== false) {
     this.setCache(key, data);
    }
    
    LoadingManager.hide(key);
    return data;
    
   } catch (error) {
    lastError = error;
    
    // ถ้าไม่ใช่ครั้งสุดท้าย ให้รอแล้วลองใหม่
    if (i < this.constants.MAX_RETRIES) {
     await new Promise(resolve =>
      setTimeout(resolve, this.constants.RETRY_DELAY * (i + 1))
     );
    }
   }
  }
  
  // ถ้าลองครบแล้วยังไม่สำเร็จ
  LoadingManager.hide(key);
  errorManager.showError(key, lastError, {
   duration: 5000,
   type: 'error',
   dismissible: true
  });
  throw lastError;
 },
 
 // โหลดข้อมูลแบบแบ่งชุด
 async fetchBatched(urls, options = {}) {
  const results = [];
  const batches = [];
  
  // แบ่งเป็นชุดๆ
  for (let i = 0; i < urls.length; i += this.constants.BATCH_SIZE) {
   batches.push(urls.slice(i, i + this.constants.BATCH_SIZE));
  }
  
  // โหลดทีละชุด
  for (const batch of batches) {
   const batchResults = await Promise.all(
    batch.map(url => this.fetchWithRetry(url, options))
   );
   results.push(...batchResults);
  }
  
  return results;
 },
 
 // ดึงข้อมูลแบบ SSE (Server-Sent Events)
 subscribeToEvents(url, callbacks = {}) {
  const eventSource = new EventSource(url);
  
  eventSource.onmessage = (event) => {
   try {
    const data = JSON.parse(event.data);
    callbacks.onMessage?.(data);
   } catch (error) {
    callbacks.onError?.(error);
   }
  };
  
  eventSource.onerror = (error) => {
   callbacks.onError?.(error);
   eventSource.close();
  };
  
  return {
   unsubscribe: () => eventSource.close()
  };
 },
 
 // เคลียร์สถานะทั้งหมด
 reset() {
  this.clearCache();
  this.loadingStates.clear();
 }
};

// ตัวอย่างการใช้งาน:
/*
// ดึงข้อมูลปกติ
try {
  const data = await DataManager.fetchWithRetry('/api/data', {
    cache: true,
    loadingMessage: 'กำลังโหลดข้อมูล...'
  });
  console.log(data);
} catch (error) {
  // จัดการข้อผิดพลาด (ErrorManager จะจัดการการแสดงข้อผิดพลาดให้อัตโนมัติ)
}

// ดึงข้อมูลแบบแบ่งชุด
const urls = ['/api/data1', '/api/data2', '/api/data3', ...];
const results = await DataManager.fetchBatched(urls, {
  cache: true
});

// ใช้งาน SSE
const subscription = DataManager.subscribeToEvents('/api/events', {
  onMessage: (data) => console.log('ได้รับข้อมูลใหม่:', data),
  onError: (error) => console.error('เกิดข้อผิดพลาด:', error)
});

// ยกเลิกการรับข้อมูล SSE
subscription.unsubscribe();
*/

const LoadingManager = {
 loaders: new Map(),
 
 show(key, message = 'กำลังโหลด...') {
  if (this.loaders.has(key)) return;
  
  const loader = utils.showNotification(message, 'loading', {
   duration: Infinity,
   dismissible: false
  });
  
  this.loaders.set(key, loader);
  
  // ตั้งเวลาตรวจสอบการโหลดที่นานเกินไป
  setTimeout(() => {
   if (this.loaders.has(key)) {
    this.hide(key);
    errorManager.showError(key, new Error('การโหลดใช้เวลานานเกินไป กรุณาลองใหม่'));
   }
  }, 10000); // 10 วินาที
 },
 
 hide(key) {
  const loader = this.loaders.get(key);
  if (loader) {
   loader.remove();
   this.loaders.delete(key);
  }
 }
};

// ScrollManager ที่ปรับปรุงใหม่ใช้ Animation-based
const ScrollManager = {
 init() {
  // ตัวแปรสำหรับควบคุมสถานะ
  const state = {
   isAnimating: false,
   lastScrollY: window.pageYOffset,
   headerVisible: true,
   animationFrame: null,
   headerHeight: 0,
   scrollDirection: 0,
   scrollTimeout: null
  };
  
  // ค่าคงที่สำหรับการปรับแต่ง
  const SETTINGS = {
   // ระยะ scroll ขั้นต่ำที่จะเริ่มทำงาน (px)
   SCROLL_THRESHOLD: 20,
   // ความเร็วในการแสดง/ซ่อน header (ms)
   ANIMATION_DURATION: 300,
   // ระยะเวลารอก่อนรีเซ็ต header (ms)
   RESET_DELAY: 130,
   // ระยะการเลื่อนขั้นต่ำที่จะเริ่มตรวจจับทิศทาง (px)
   DIRECTION_THRESHOLD: 5,
   // ความเร็วในการ scroll ที่จะทริกเกอร์ animation (px/ms)
   VELOCITY_THRESHOLD: 0.5
  };
  
  // Keyframes สำหรับ animation
  const ANIMATIONS = {
   hideHeader: [
    { transform: 'translateY(0)', offset: 0 },
    { transform: 'translateY(-50%)', offset: 1 }
   ],
   showHeader: [
    { transform: 'translateY(-50%)', offset: 0 },
    { transform: 'translateY(0)', offset: 1 }
   ]
  };
  
  // Animation timing
  const TIMING = {
   duration: SETTINGS.ANIMATION_DURATION,
   easing: 'cubic-bezier(0.4, 0.0, 0.2, 1)', // Material Design easing
   fill: 'forwards'
  };
  
  // ฟังก์ชันสำหรับคำนวณความเร็วการ scroll
  const calculateScrollVelocity = (() => {
   let lastScrollY = window.pageYOffset;
   let lastScrollTime = performance.now();
   
   return () => {
    const currentScrollY = window.pageYOffset;
    const currentTime = performance.now();
    const timeDiff = currentTime - lastScrollTime;
    const scrollDiff = currentScrollY - lastScrollY;
    
    lastScrollY = currentScrollY;
    lastScrollTime = currentTime;
    
    return timeDiff > 0 ? scrollDiff / timeDiff : 0;
   };
  })();
  
  // ฟังก์ชันจัดการ animation
  const animateHeader = (show) => {
   const { header } = elements;
   if (!header || state.isAnimating) return;
   
   // ยกเลิก animation ที่กำลังเล่นอยู่
   header.getAnimations().forEach(animation => animation.cancel());
   
   // สร้างและเริ่ม animation ใหม่
   const animation = header.animate(
    show ? ANIMATIONS.showHeader : ANIMATIONS.hideHeader,
    TIMING
   );
   
   state.isAnimating = true;
   state.headerVisible = show;
   
   animation.onfinish = () => {
    state.isAnimating = false;
   };
  };
  
  // ฟังก์ชันหลักจัดการ scroll
  const handleScroll = () => {
   if (state.animationFrame) {
    cancelAnimationFrame(state.animationFrame);
   }
   
   state.animationFrame = requestAnimationFrame(() => {
    const currentScrollY = window.pageYOffset;
    const scrollDiff = currentScrollY - state.lastScrollY;
    const velocity = calculateScrollVelocity();
    
    // ตรวจสอบทิศทางและความเร็วของการ scroll
    if (Math.abs(scrollDiff) > SETTINGS.DIRECTION_THRESHOLD) {
     const scrollingDown = scrollDiff > 0;
     const velocityTriggered = Math.abs(velocity) > SETTINGS.VELOCITY_THRESHOLD;
     
     // เช็คเงื่อนไขการแสดง/ซ่อน header
     if (currentScrollY > SETTINGS.SCROLL_THRESHOLD) {
      if (scrollingDown && state.headerVisible && velocityTriggered) {
       // ซ่อน header เมื่อเลื่อนลงเร็วๆ
       animateHeader(false);
      } else if (!scrollingDown && !state.headerVisible && velocityTriggered) {
       // แสดง header เมื่อเลื่อนขึ้นเร็วๆ
       animateHeader(true);
      }
     } else if (currentScrollY <= 0 && !state.headerVisible) {
      // แสดง header เมื่ออยู่บนสุด
      animateHeader(true);
     }
    }
    
    state.lastScrollY = currentScrollY;
    state.scrollDirection = scrollDiff;
   });
   
   // รีเซ็ต timeout สำหรับการตรวจสอบการหยุด scroll
   clearTimeout(state.scrollTimeout);
   state.scrollTimeout = setTimeout(() => {
    const currentScrollY = window.pageYOffset;
    if (currentScrollY <= SETTINGS.SCROLL_THRESHOLD && !state.headerVisible) {
     animateHeader(true);
    }
   }, SETTINGS.RESET_DELAY);
  };
  
  // Touch handling สำหรับมือถือ
  let touchStartY = 0;
  let lastTouchY = 0;
  let touchStartTime = 0;
  
  const handleTouchStart = (e) => {
   touchStartY = e.touches[0].clientY;
   lastTouchY = touchStartY;
   touchStartTime = performance.now();
   state.isAnimating = false;
  };
  
  const handleTouchMove = (e) => {
   const currentY = e.touches[0].clientY;
   const touchDiff = currentY - lastTouchY;
   const timeDiff = performance.now() - touchStartTime;
   const velocity = touchDiff / timeDiff;
   
   if (Math.abs(velocity) > SETTINGS.VELOCITY_THRESHOLD) {
    if (velocity > 0 && !state.headerVisible) {
     animateHeader(true);
    } else if (velocity < 0 && state.headerVisible) {
     animateHeader(false);
    }
   }
   
   lastTouchY = currentY;
  };
  
  // Event Listeners
  window.addEventListener('scroll', handleScroll, { passive: true });
  window.addEventListener('touchstart', handleTouchStart, { passive: true });
  window.addEventListener('touchmove', handleTouchMove, { passive: true });
  
  // Resize Observer
  const resizeObserver = new ResizeObserver((entries) => {
   for (const entry of entries) {
    if (entry.target === elements.header) {
     state.headerHeight = entry.contentRect.height;
    }
   }
  });
  
  if (elements.header) {
   resizeObserver.observe(elements.header);
  }
 },
 
 // รีเซ็ต ScrollManager
 reset() {
  const { header } = elements;
  if (header) {
   header.getAnimations().forEach(animation => animation.cancel());
   header.style.transform = 'translateY(0)';
  }
 }
};

const ButtonManager = {
 async loadConfig() {
  try {
   if (state.buttonConfig) {
    this.renderMainButtons();
    return;
   }
   
   const cached = DataManager.getCached('buttonConfig');
   if (cached) {
    state.buttonConfig = cached;
    this.renderMainButtons();
    return;
   }
   
   const response = await DataManager.fetchWithRetry('/assets/json/buttons.min.json');
   state.buttonConfig = response;
   DataManager.setCache('buttonConfig', response);
   
   await this.renderMainButtons();
   await NavigationManager.updateButtonStates();
   
  } catch (error) {
   throw new AppError('ไม่สามารถโหลดการตั้งค่าปุ่มได้', 'config', error);
  }
 },
 
 async renderMainButtons() {
  const lang = localStorage.getItem('selectedLang') || 'en';
  const { mainButtons } = state.buttonConfig;
  const { navList } = elements;
  
  navList.innerHTML = '';
  
  // สร้างแมพของปุ่มเพื่อเก็บการอ้างอิง
  const buttonMap = new Map();
  let defaultButton = null;
  
  mainButtons.forEach(button => {
   const label = button[`${lang}_label`];
   if (!label) return;
   
   const li = document.createElement('li');
   const mainButton = document.createElement('button');
   mainButton.textContent = label;
   
   const buttonUrl = button.url || button.jsonFile;
   mainButton.setAttribute('data-url', buttonUrl);
   
   // เก็บการอ้างอิงปุ่มและข้อมูล
   buttonMap.set(buttonUrl, {
    button: mainButton,
    config: button
   });
   
   if (button.isDefault) {
    defaultButton = {
     button: mainButton,
     config: button
    };
   }
   
   mainButton.addEventListener('click', async () => {
    try {
     await ContentManager.clearContent();
     
     // ถ้ามี subButtons ไม่ต้องอัพเดท URL
     const skipUrlUpdate = !!button.subButtons;
     
     if (!button.subButtons && button.url) {
      await NavigationManager.navigateTo(button.url, { skipUrlUpdate });
     }
     
     if (button.jsonFile) {
      const data = await DataManager.fetchWithRetry(button.jsonFile);
      await ContentManager.renderContent(data);
     } else if (button.subButtons) {
      await this.renderSubButtons(button.subButtons, buttonUrl, lang);
     }
    } catch (error) {
     utils.showNotification(error.message, 'error');
    }
   });
   
   li.appendChild(mainButton);
   navList.appendChild(li);
  });
  
  // จัดการ URL เริ่มต้น
  const initialUrl = window.location.hash.replace('#', '');
  await this.handleInitialUrl(initialUrl, buttonMap, defaultButton);
 },
 
 async handleInitialUrl(url, buttonMap, defaultButton) {
  try {
   if (!url) {
    if (defaultButton) {
     await this.triggerButtonClick(defaultButton.button);
    }
    return;
   }
   
   const [mainRoute, subRoute] = url.split('-');
   const mainButtonData = buttonMap.get(mainRoute);
   
   if (mainButtonData) {
    const { button, config } = mainButtonData;
    
    // คลิกปุ่มหลักโดยไม่อัพเดท URL
    await this.triggerButtonClick(button, { skipUrlUpdate: true });
    
    // ถ้ามี sub-route และปุ่มหลักมี subButtons
    if (subRoute && config.subButtons) {
     await new Promise(resolve => setTimeout(resolve, 100));
     
     // หา sub-button และคลิก
     const subButton = document.querySelector(`button[data-url="${url}"]`);
     if (subButton) {
      await this.triggerButtonClick(subButton);
     } else {
      // ถ้าไม่พบ sub-button ให้ใช้ปุ่ม default
      await this.handleDefaultSubButton(config);
     }
    }
    return;
   }
   
   // กรณี URL ไม่ถูกต้อง ใช้ปุ่ม default
   if (defaultButton) {
    await this.triggerButtonClick(defaultButton.button);
   }
   
  } catch (error) {
   console.error('Error handling initial URL:', error);
   utils.showNotification('เกิดข้อผิดพลาดในการนำทาง กรุณาลองใหม่', 'error');
  }
 },
 
 async triggerButtonClick(button, options = {}) {
  if (button && button.click) {
   const clickEvent = new MouseEvent('click', {
    bubbles: true,
    cancelable: true,
    view: window,
    ...options
   });
   button.dispatchEvent(clickEvent);
  }
 },
 
 async handleDefaultSubButton(config) {
  const defaultSubButton = config.subButtons.find(sub => sub.isDefault);
  if (defaultSubButton) {
   const fullUrl = `${config.url}-${defaultSubButton.url || defaultSubButton.jsonFile}`;
   await NavigationManager.navigateTo(fullUrl);
  }
 },
 
 async renderSubButtons(subButtons, mainButtonUrl, lang) {
  const { subButtonsContainer } = elements;
  
  // เคลียร์และเตรียม container
  subButtonsContainer.innerHTML = '';
  subButtonsContainer.classList.add('fade-out');
  
  await new Promise(resolve => setTimeout(resolve, 100));
  
  let defaultSubButton = null;
  const subButtonMap = new Map();
  
  // สร้างปุ่มย่อย
  subButtons.forEach(button => {
   const label = button[`${lang}_label`];
   if (!label) return;
   
   const subButton = document.createElement('button');
   subButton.className = 'button-sub sub-button';
   subButton.textContent = label;
   
   const fullUrl = button.url ?
    `${mainButtonUrl}-${button.url}` :
    `${mainButtonUrl}-${button.jsonFile}`;
   
   subButton.setAttribute('data-url', fullUrl);
   
   // เก็บการอ้างอิงปุ่มย่อย
   subButtonMap.set(fullUrl, subButton);
   if (button.isDefault) {
    defaultSubButton = subButton;
   }
   
   // จัดการการคลิกปุ่มย่อย
   subButton.addEventListener('click', async () => {
    try {
     // ล้าง active state ของปุ่มอื่นๆ
     subButtonsContainer.querySelectorAll('.button-sub').forEach(btn => {
      btn.classList.remove('active');
     });
     
     // ทำให้ปุ่มที่ถูกคลิกเป็น active
     subButton.classList.add('active');
     
     // เลื่อนปุ่มไปทางซ้าย
     this.scrollActiveSubButtonIntoView(subButton);
     
     // อัพเดท URL และโหลดเนื้อหา
     await Promise.all([
      NavigationManager.navigateTo(fullUrl),
      button.jsonFile ? (async () => {
       const data = await DataManager.fetchWithRetry(button.jsonFile);
       await ContentManager.renderContent(data);
      })() : Promise.resolve()
     ]);
     
    } catch (error) {
     utils.showNotification(error.message, 'error');
    }
   });
   
   subButtonsContainer.appendChild(subButton);
  });
  
  // จัดการปุ่ม default และ animation
  if (defaultSubButton) {
   await this.triggerButtonClick(defaultSubButton);
  }
  
  subButtonsContainer.classList.remove('fade-out');
  subButtonsContainer.classList.add('fade-in');
 },
 
 scrollActiveSubButtonIntoView(activeButton) {
  if (!activeButton) return;
  
  const container = elements.subButtonsContainer;
  if (!container) return;
  
  requestAnimationFrame(() => {
   const containerLeft = container.getBoundingClientRect().left;
   const buttonLeft = activeButton.getBoundingClientRect().left;
   const scrollLeft = container.scrollLeft;
   
   const targetScroll = scrollLeft + (buttonLeft - containerLeft) - 20;
   
   if (Math.abs(container.scrollLeft - targetScroll) > 1) {
    container.scrollTo({
     left: targetScroll,
     behavior: 'smooth'
    });
   }
  });
 },
 
 // ฟังก์ชันสำหรับอัพเดทภาษาของปุ่ม
 updateButtonsLanguage(newLang) {
  const { mainButtons } = state.buttonConfig;
  const { navList, subButtonsContainer } = elements;
  
  // อัพเดทปุ่มหลัก
  navList.querySelectorAll('button').forEach((button, index) => {
   const config = mainButtons[index];
   if (config && config[`${newLang}_label`]) {
    button.textContent = config[`${newLang}_label`];
   }
  });
  
  // อัพเดทปุ่มย่อย
  if (subButtonsContainer) {
   const activeMainButton = navList.querySelector('button.active');
   if (activeMainButton) {
    const mainButtonConfig = mainButtons.find(btn =>
     btn.url === activeMainButton.getAttribute('data-url') ||
     btn.jsonFile === activeMainButton.getAttribute('data-url')
    );
    
    if (mainButtonConfig && mainButtonConfig.subButtons) {
     this.renderSubButtons(mainButtonConfig.subButtons, mainButtonConfig.url, newLang);
    }
   }
  }
 }
};

    // Performance Optimizations
    const PerformanceOptimizer = {
     init() {
      this.setupLazyLoading();
      this.setupPrefetching();
      this.setupErrorBoundary();
     },
     
     setupLazyLoading() {
      if ('loading' in HTMLImageElement.prototype) {
       document.querySelectorAll('img').forEach(img => {
        img.loading = 'lazy';
       });
      } else {
       this.setupIntersectionObserver();
      }
     },
     
     setupIntersectionObserver() {
      const imageObserver = new IntersectionObserver((entries, observer) => {
       entries.forEach(entry => {
        if (entry.isIntersecting) {
         const img = entry.target;
         if (img.dataset.src) {
          img.src = img.dataset.src;
          img.removeAttribute('data-src');
         }
         observer.unobserve(img);
        }
       });
      });
      
      document.querySelectorAll('img[data-src]').forEach(img => {
       imageObserver.observe(img);
      });
     },
     
     setupPrefetching() {
      const prefetchLinks = new Set();
      
      document.querySelectorAll('a[href], button[data-url]').forEach(element => {
       const url = element.href || element.dataset.url;
       if (url && !prefetchLinks.has(url)) {
        const link = document.createElement('link');
        link.rel = 'prefetch';
        link.href = url;
        link.as = url.endsWith('.json') ? 'fetch' : 'document';
        document.head.appendChild(link);
        prefetchLinks.add(url);
       }
      });
     },
     
     setupErrorBoundary() {
      window.addEventListener('error', event => {
       console.error('Global error:', event.error);
       utils.showNotification(
        'เกิดข้อผิดพลาดที่ไม่คาดคิด กรุณาลองใหม่อีกครั้ง',
        'error'
       );
      });
      
      window.addEventListener('unhandledrejection', event => {
       console.error('Unhandled promise rejection:', event.reason);
       utils.showNotification(
        'เกิดข้อผิดพลาดในการเชื่อมต่อ กรุณาตรวจสอบการเชื่อมต่ออินเทอร์เน็ต',
        'error'
       );
      });
     }
    };
    
    // Event Listeners and Initialization
    const initializeApp = async () => {
     try {
      // Initialize scroll handling
      ScrollManager.init();
      
      // Initialize performance optimizations
      PerformanceOptimizer.init();
      
      // Setup button event listeners
      elements.navButtons.forEach(button => {
       button.addEventListener('click', async event => {
        event.preventDefault();
        const route = button.getAttribute('data-url');
        if (route) {
         try {
          await NavigationManager.navigateTo(route);
         } catch (error) {
          utils.showNotification(error.message, 'error');
         }
        }
       });
      });
      
        // ปรับปรุงการจัดการ URL changes
  window.addEventListener('popstate', () => {
   if (!NavigationManager.state.isNavigating) {
    NavigationManager.updateButtonStates();
   }
  });
  
  window.addEventListener('hashchange', (event) => {
   if (!NavigationManager.state.isNavigating) {
    const newHash = event.newURL.split('#')[1] || '';
    NavigationManager.navigateTo(newHash);
   }
  });
  
  // เพิ่มการจัดการ beforeunload
  window.addEventListener('beforeunload', () => {
   NavigationManager.state.isInitialLoad = true;
  });
      
      // Setup network status monitoring
      window.addEventListener('online', () => {
       utils.showNotification('การเชื่อมต่อกลับมาแล้ว', 'success');
      });
      
      window.addEventListener('offline', () => {
       utils.showNotification('ขาดการเชื่อมต่ออินเทอร์เน็ต', 'warning');
      });
      
      // Handle URL changes
      window.addEventListener('popstate', () => {
       NavigationManager.updateButtonStates();
      });
      
      window.addEventListener('hashchange', () => {
       NavigationManager.updateButtonStates();
      });
      
      // Load initial configuration
      await ButtonManager.loadConfig();
      
     } catch (error) {
      console.error('Initialization error:', error);
      utils.showNotification(
       'เกิดข้อผิดพลาดในการเริ่มต้นแอปพลิเคชัน กรุณารีเฟรชหน้า',
       'error'
      );
     }
    };
    
    // เพิ่ม Event Listener สำหรับการเปลี่ยนภาษา
window.addEventListener('languageChange', (event) => {
  const newLang = event.detail.language;
  this.updateCardsLanguage(newLang);
});
    
    // Start the application
    if (document.readyState === 'loading') {
     document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
     initializeApp();
    }
    });