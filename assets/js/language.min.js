/**
 * LanguageManager - ระบบจัดการภาษาสำหรับเว็บไซต์
 *
 * เวอร์ชั่น 2.5.2
 * ในเวอร์ชั่นนี้ ได้ปรับปรุงให้ระบบสามารถควบคุมค่า attribute lang ของ <html> ได้อย่างชาญฉลาด
 * เพื่อป้องกันไม่ให้ browser ระบุภาษาที่ไม่ถูกต้องเมื่อมีการเปลี่ยนภาษา
 * ด้วยเทคนิคการตรวจสอบและรีเซ็ต attribute lang โดยใช้ MutationObserver ในระดับ <html>
 *
 * ฟังก์ชันและตรรกะการทำงานที่เหลือยังคงเหมือนเดิม
 */
class LanguageManager {
  constructor() {
    // ตัวแปรพื้นฐาน
    this.languagesConfig = {};
    this.selectedLang = '';
    this.lastSelectedLang = ''; // เก็บภาษาล่าสุด
    this.isLanguageDropdownOpen = false;
    this.languageCache = new Map(); // สำหรับ cache ภาษา DSL
    this.isUpdatingLanguage = false;
    this.isNavigating = false; // ควบคุมการนำทาง
    this.mutationObserver = null;
    this.htmlLangObserver = null; // Observer สำหรับ <html> lang attribute
    this.scrollPosition = 0;

    // ค่าคงที่ปรับปรุง
    this.RETRY_ATTEMPTS = 3;
    this.RETRY_DELAY = 0; // ไม่มี delay สำหรับการ retry
    this.FADE_DURATION = 300; // ยังคงมี animation สำหรับ dropdown
    this.UPDATE_DELAY = 0;  // ไม่มี delay เพื่อให้การแปลทันที

    // Throttling for MutationObserver (เล็กน้อยสำหรับการรวบรวมการเปลี่ยนแปลง)
    this.mutationThrottleTimeout = null;

    // สถานะการโหลด
    this.isInitialized = false;
    this.pendingTranslations = new Map();

    // เปิด IndexedDB สำหรับเก็บข้อมูล DSL และ config
    this.dbPromise = this.openIndexedDB();
  }

  /**
   * เปิด IndexedDB สำหรับ cache DSL และ config
   */
  openIndexedDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('language_data_store', 1);
      request.onupgradeneeded = () => {
        const db = request.result;
        if (!db.objectStoreNames.contains('dsl')) {
          db.createObjectStore('dsl', { keyPath: 'languageCode' });
        }
        if (!db.objectStoreNames.contains('config')) {
          db.createObjectStore('config', { keyPath: 'key' });
        }
      };
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * ดึง config จาก IndexedDB store "config"
   */
  getConfigFromIndexedDB() {
    return this.dbPromise.then(db => {
      return new Promise((resolve, reject) => {
        const tx = db.transaction('config', 'readonly');
        const store = tx.objectStore('config');
        const req = store.get('languagesConfig');
        req.onsuccess = () => { resolve(req.result ? req.result.data : null); };
        req.onerror = () => reject(req.error);
      });
    });
  }

  /**
   * บันทึก config ลง IndexedDB ใน store "config"
   */
  storeConfigInIndexedDB(configData) {
    return this.dbPromise.then(db => {
      return new Promise((resolve, reject) => {
        const tx = db.transaction('config', 'readwrite');
        const store = tx.objectStore('config');
        const req = store.put({ key: 'languagesConfig', data: configData });
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    });
  }

  /**
   * ดึงข้อมูล DSL จาก IndexedDB
   */
  getDSLFromIndexedDB(languageCode) {
    return this.dbPromise.then(db => {
      return new Promise((resolve, reject) => {
        const tx = db.transaction('dsl', 'readonly');
        const store = tx.objectStore('dsl');
        const req = store.get(languageCode);
        req.onsuccess = () => { resolve(req.result ? req.result.data : null); };
        req.onerror = () => reject(req.error);
      });
    });
  }

  /**
   * บันทึกข้อมูล DSL ลง IndexedDB
   */
  storeDSLInIndexedDB(languageCode, data) {
    return this.dbPromise.then(db => {
      return new Promise((resolve, reject) => {
        const tx = db.transaction('dsl', 'readwrite');
        const store = tx.objectStore('dsl');
        const req = store.put({ languageCode, data });
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    });
  }

  /**
   * เริ่มต้นระบบ
   */
  async initialize() {
    if (this.isInitialized) return;
    try {
      await this.loadLanguagesConfig();
      this.observeMutations();
      this.setupNavigationHandlers();
      // กำหนด <html> ให้ lang ว่าง เพื่อระบบของเราจัดการเอง
      document.documentElement.setAttribute("lang", "");
      // เริ่มต้น observer เพื่อตรวจสอบการเปลี่ยนแปลงของ <html> lang และบังคับ override
      this.startHtmlLangObserver();
      this.isInitialized = true;
    } catch (error) {
      console.error('Error during initialization:', error);
      this.showError('ไม่สามารถเริ่มต้นระบบได้');
    }
  }

  /**
   * เริ่มต้น observer สำหรับ <html> lang attribute เพื่อตรวจจับและรีเซ็ตให้ตรงกับภาษาของระบบ
   */
  startHtmlLangObserver() {
    if (this.htmlLangObserver) {
      this.htmlLangObserver.disconnect();
    }
    this.htmlLangObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === 'lang') {
          const currentLang = document.documentElement.getAttribute("lang");
          // ถ้าภาษาที่ถูกตั้งไม่ตรงกับภาษาที่ถูกเลือกในระบบ ให้รีเซ็ตให้ตรง
          if (currentLang !== this.selectedLang) {
            document.documentElement.setAttribute("lang", this.selectedLang);
          }
        }
      });
    });
    this.htmlLangObserver.observe(document.documentElement, { attributes: true });
  }

  /**
   * โหลด configuration ภาษา
   *
   * languagesConfig จะถูกโหลดจาก IndexedDB (หรือจากไฟล์ JSON แล้วบันทึกลง IndexedDB)
   */
  async loadLanguagesConfig() {
    try {
      const storedConfig = await this.getStoredConfig();
      if (storedConfig && await this.validateConfig(storedConfig)) {
        this.languagesConfig = storedConfig;
      } else {
        await this.fetchAndSetConfig();
      }
      await this.handleInitialLanguage();
      this.initializeCustomLanguageSelector();
    } catch (error) {
      console.error('Error loading language configuration:', error);
      this.showError('ไม่สามารถโหลดข้อมูลภาษาได้');
      this.fallbackToDefaultLanguage();
    }
  }

  /**
   * ดึงข้อมูล config จาก IndexedDB แทน LocalStorage
   */
  async getStoredConfig() {
    try {
      const storedConfig = await this.getConfigFromIndexedDB();
      return storedConfig;
    } catch {
      return null;
    }
  }

  /**
   * ตรวจสอบความถูกต้องของ config
   */
  async validateConfig(config) {
    return config &&
      typeof config === 'object' &&
      Object.keys(config).length > 0 &&
      Object.values(config).every(lang =>
        lang.label &&
        lang.buttonText &&
        typeof lang.label === 'string' &&
        typeof lang.buttonText === 'string'
      );
  }

  /**
   * ดึงและตั้งค่า config ใหม่ จากไฟล์ JSON แล้วบันทึกใน IndexedDB
   */
  async fetchAndSetConfig() {
    for (let attempt = 1; attempt <= this.RETRY_ATTEMPTS; attempt++) {
      try {
        const response = await fetch('/assets/json/language.min.json');
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const newConfig = await response.json();
        if (await this.validateConfig(newConfig)) {
          this.languagesConfig = newConfig;
          await this.storeConfigInIndexedDB(newConfig);
          return;
        }
        throw new Error('Invalid config format');
      } catch (error) {
        if (attempt === this.RETRY_ATTEMPTS) throw error;
      }
    }
  }

  /**
   * จัดการภาษาเริ่มต้น
   */
  async handleInitialLanguage() {
    this.storeOriginalContent();
    const urlParams = new URLSearchParams(window.location.search);
    const langFromUrl = urlParams.get('lang');
    const historyState = window.history.state;
    // ใช้ค่าภาษาจาก localStorage เป็นหลัก
    const storedLang = localStorage.getItem('selectedLang') || 'en';
    this.selectedLang = storedLang;
    if (this.selectedLang !== 'en') {
      await this.updatePageLanguage(this.selectedLang, { updateHistory: false });
    }
  }

  /**
   * กำหนดภาษาเริ่มต้น
   */
  determineInitialLanguage(langFromUrl) {
    if (langFromUrl && this.languagesConfig[langFromUrl]) return langFromUrl;
    const storedLang = localStorage.getItem('selectedLang');
    if (storedLang && this.languagesConfig[storedLang]) return storedLang;
    return this.detectBrowserLanguage();
  }

  /**
   * ตรวจจับภาษาของเบราว์เซอร์
   */
  detectBrowserLanguage() {
    const browserLanguages = navigator.languages || [navigator.language || navigator.userLanguage];
    return browserLanguages
      .map(lang => lang.split('-')[0])
      .find(lang => this.languagesConfig[lang]) || 'en';
  }

  /**
   * อัพเดทภาษาของหน้าเว็บ
   *
   * ระบบจะจัดการ attribute lang ของ <html> ให้ทันทีตามที่เลือก
   */
  async updatePageLanguage(language, options = { updateHistory: true }) {
    if (this.isUpdatingLanguage) return;
    try {
      this.isUpdatingLanguage = true;
      this.lastSelectedLang = this.selectedLang;
      // รีเซ็ตค่า lang ของ <html> และเซ็ตค่าใหม่ให้ตรงกับระบบของเรา
      document.documentElement.setAttribute("lang", "");
      document.documentElement.setAttribute("lang", language);
      // หลังจากเปลี่ยนค่า lang ให้เริ่ม observer สำหรับ <html> ใหม่
      this.startHtmlLangObserver();

      if (language === 'en') {
        await this.resetToEnglishContent();
      } else {
        const languageData = await this.loadLanguageData(language);
        if (languageData) {
          if (window.requestIdleCallback) {
            requestIdleCallback(() => this.translatePageContent(languageData));
          } else {
            await this.translatePageContent(languageData);
          }
        } else {
          await this.resetToEnglishContent();
        }
      }
      this.selectedLang = language;
      // ใช้ microtask scheduling เพื่ออัพเดทข้อความในปุ่มทันที
      Promise.resolve().then(() => this.updateButtonText());
      if (options.updateHistory) this.updateURLAndHistory(language);
      localStorage.setItem('selectedLang', language);
    } catch (error) {
      console.error('Error updating page language:', error);
      this.showError('เกิดข้อผิดพลาดในการเปลี่ยนภาษา');
      await this.resetToEnglishContent();
    } finally {
      this.isUpdatingLanguage = false;
    }
  }

  /**
   * อัพเดท URL และ Browser History
   */
  updateURLAndHistory(language) {
    const url = new URL(window.location.href);
    if (language === 'en') {
      url.searchParams.delete('lang');
    } else {
      url.searchParams.set('lang', language);
    }
    const newUrl = url.toString();
    if (newUrl === window.location.href) return;
    const state = {
      language: language,
      lastLanguage: this.lastSelectedLang,
      timestamp: Date.now()
    };
    history.replaceState(state, '', newUrl);
  }

  /**
   * โหลดข้อมูลภาษา (รองรับ DSL)
   *
   * ตรวจสอบ IndexedDB ก่อน หากไม่มีจึงโหลดจากไฟล์ DSL แล้วบันทึกลง IndexedDB
   */
  async loadLanguageData(languageCode) {
    if (this.languageCache.has(languageCode)) {
      return this.languageCache.get(languageCode);
    }
    let data = await this.getDSLFromIndexedDB(languageCode);
    if (data) {
      this.languageCache.set(languageCode, data);
      return data;
    }
    const dslPath = `/assets/dsl/${languageCode}.min.dsl`;
    for (let attempt = 1; attempt <= this.RETRY_ATTEMPTS; attempt++) {
      try {
        const response = await fetch(dslPath);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const dslText = await response.text();
        data = this.parseDSL(dslText);
        if (this.validateLanguageData(data)) {
          this.languageCache.set(languageCode, data);
          await this.storeDSLInIndexedDB(languageCode, data);
          return data;
        }
        throw new Error('Invalid DSL language data format');
      } catch (error) {
        if (attempt === this.RETRY_ATTEMPTS) {
          console.error(`ไม่สามารถโหลดภาษา ${languageCode} ได้:`, error);
          this.showError(`ไม่สามารถโหลดภาษา ${languageCode} ได้`);
          return null;
        }
      }
    }
  }

  /**
   * แปลงเนื้อหา DSL เป็น object
   *
   * - ข้ามบรรทัดที่ขึ้นต้นด้วย "$" (engagement header)
   * - สำหรับบรรทัดในรูปแบบ key "value"
   * - ถ้า key มีเครื่องหมาย "/" ให้ใช้ส่วนหลังเป็น key สำหรับการแปล
   */
  parseDSL(dslText) {
    const data = {};
    const lines = dslText.split(/\r?\n/);
    for (const line of lines) {
      if (!line.trim() || line.trim().startsWith("#")) continue;
      if (line.trim().startsWith("$")) continue;
      const match = line.match(/^\s*([^"\s]+)\s+"(.*)"\s*$/);
      if (match) {
        let key = match[1].trim();
        const value = match[2].trim();
        if (key.includes("/")) {
          const parts = key.split("/");
          key = parts[parts.length - 1].trim();
        }
        data[key] = value;
      }
    }
    return data;
  }

  /**
   * จัดการ navigation events โดยอ่านจาก localStorage เพื่อป้องกันการ revert ภาษาของหน้าก่อนหน้า
   */
  setupNavigationHandlers() {
    window.addEventListener('popstate', async (event) => {
      if (this.isLanguageDropdownOpen) await this.closeLanguageDropdown();
      if (this.isNavigating) return;
      this.isNavigating = true;
      try {
        // อ่านภาษาปัจจุบันจาก localStorage แทนค่า event.state
        const storedLang = localStorage.getItem('selectedLang') || 'en';
        if (storedLang !== this.selectedLang) {
          await this.updatePageLanguage(storedLang, { updateHistory: false });
        }
      } finally {
        this.isNavigating = false;
      }
    });
  }

  /**
   * แปลเนื้อหาในหน้าเว็บ
   *
   * รองรับ marker สำหรับ:
   *  - ลิงค์: @a[ข้อความที่ต้องการ]@ (ถ้าเป็น "@a@" ไม่แปลแท็ก <a>)
   *  - <br>: @br (แทนที่ด้วย <br>)
   *  - <strong>: @strong ข้อความ@ (แทนที่ด้วย <strong>ข้อความ</strong>)
   *
   * ทำการประมวลผล DOM หลาย element พร้อมกันด้วย Promise.all
   */
  async translatePageContent(languageData) {
    const elements = document.querySelectorAll('[data-translate]');
    await Promise.all(
      Array.from(elements).map(async (el) => {
        const key = el.getAttribute('data-translate');
        if (!languageData[key]) return;
        let translation = languageData[key];
        translation = translation.replace(/@br/g, "<br>");
        translation = translation.replace(/@strong(.*?)@/g, "<strong>$1</strong>");
        const hasMedia = el.querySelector('img, svg');
        if (/@a(.*?)@/.test(translation)) {
          if (!hasMedia) {
            const parts = translation.split(/(@a.*?@)/);
            const anchorElements = Array.from(el.querySelectorAll('a'));
            let anchorIndex = 0;
            const newHTML = parts.map(part => {
              const markerMatch = part.match(/^@a(.*?)@$/);
              if (markerMatch) {
                const translatedLinkText = markerMatch[1];
                if (translatedLinkText.trim() === "") {
                  if (anchorIndex < anchorElements.length) {
                    const origAnchor = anchorElements[anchorIndex++];
                    let attrString = "";
                    Array.from(origAnchor.attributes).forEach(attr => {
                      attrString += ` ${attr.name}="${attr.value}"`;
                    });
                    return `<a${attrString}>${origAnchor.textContent}</a>`;
                  }
                  return "";
                }
                if (anchorIndex < anchorElements.length) {
                  const origAnchor = anchorElements[anchorIndex++];
                  let attrString = "";
                  Array.from(origAnchor.attributes).forEach(attr => {
                    attrString += ` ${attr.name}="${attr.value}"`;
                  });
                  return `<a${attrString}>${translatedLinkText}</a>`;
                } else {
                  return translatedLinkText;
                }
              } else {
                return part;
              }
            }).join('');
            el.innerHTML = newHTML;
          } else {
            const regex = /@a(.*?)@/g;
            let matches = [];
            let match;
            while ((match = regex.exec(translation)) !== null) {
              matches.push(match[1]);
            }
            const anchorElements = Array.from(el.querySelectorAll('a'));
            anchorElements.forEach((a, index) => {
              if (matches[index] && matches[index].trim() !== "") {
                a.textContent = matches[index];
              }
            });
            const plainTranslation = translation.replace(/@a.*?@/g, '');
            this.replaceTextOnly(el, plainTranslation);
          }
        } else {
          if (!hasMedia) {
            el.innerHTML = translation;
          } else {
            this.replaceTextOnly(el, translation);
          }
        }
      })
    );
  }

  /**
   * แทนที่ข้อความใน text nodes เท่านั้น (ไม่เปลี่ยนแปลง img, svg)
   */
  replaceTextOnly(element, newText) {
    element.childNodes.forEach((node) => {
      if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
        node.textContent = newText;
      } else if (node.nodeType === Node.ELEMENT_NODE && !['IMG', 'SVG'].includes(node.tagName)) {
        this.replaceTextOnly(node, newText);
      }
    });
  }

  /**
   * จัดการ UI ของตัวเลือกภาษา
   */
  initializeCustomLanguageSelector() {
    const container = document.getElementById('language-selector-container');
    if (!container) return;
    this.createLanguageElements();
    this.setupEventListeners();
  }

  /**
   * สร้าง UI elements สำหรับตัวเลือกภาษา
   */
  createLanguageElements() {
    this.languageOverlay = document.createElement('div');
    this.languageOverlay.id = 'language-overlay';
    document.body.appendChild(this.languageOverlay);

    const container = document.getElementById('language-selector-container');
    this.languageButton = document.createElement('button');
    this.languageButton.id = 'language-button';
    this.languageButton.className = container.getAttribute('lang-class') || 'default-lang-class';
    this.updateButtonText();
    container.appendChild(this.languageButton);

    this.languageDropdown = document.createElement('div');
    this.languageDropdown.id = 'language-dropdown';
    this.populateLanguageDropdown();
    document.body.appendChild(this.languageDropdown);
  }

  /**
   * เพิ่มตัวเลือกภาษาใน dropdown
   */
  populateLanguageDropdown() {
    const fragment = document.createDocumentFragment();
    Object.entries(this.languagesConfig).forEach(([lang, config]) => {
      const option = document.createElement('div');
      option.className = 'language-option';
      option.textContent = config.label;
      option.dataset.language = lang;
      fragment.appendChild(option);
    });
    this.languageDropdown.appendChild(fragment);
  }

  /**
   * ตั้งค่า event listeners
   */
  setupEventListeners() {
    this.languageButton.addEventListener('click', () => this.toggleLanguageDropdown());
    this.languageOverlay.addEventListener('click', () => this.closeLanguageDropdown());
    this.languageDropdown.addEventListener('click', (e) => {
      const option = e.target.closest('.language-option');
      if (option) {
        const lang = option.dataset.language;
        if (lang) this.selectLanguage(lang);
      }
    });
  }

  /**
   * สลับการแสดง/ซ่อน dropdown
   */
  toggleLanguageDropdown() {
    this.isLanguageDropdownOpen ? this.closeLanguageDropdown() : this.openLanguageDropdown();
  }

  /**
   * เปิด dropdown
   */
  async openLanguageDropdown() {
    if (this.isLanguageDropdownOpen) return;
    this.scrollPosition = window.scrollY;
    this.isLanguageDropdownOpen = true;
    this.languageOverlay.style.display = 'block';
    this.languageDropdown.style.display = 'block';
    document.body.style.top = `-${this.scrollPosition}px`;
    document.body.classList.add('scroll-lock');
    return new Promise(resolve => {
      requestAnimationFrame(() => {
        this.languageOverlay.classList.add('fade-in');
        this.languageDropdown.classList.add('fade-in');
        setTimeout(resolve, this.FADE_DURATION);
      });
    });
  }

  /**
   * ปิด dropdown
   */
  async closeLanguageDropdown() {
    if (!this.isLanguageDropdownOpen) return;
    return new Promise(resolve => {
      this.isLanguageDropdownOpen = false;
      this.languageOverlay.classList.remove('fade-in');
      this.languageDropdown.classList.remove('fade-in');
      this.languageOverlay.classList.add('fade-out');
      this.languageDropdown.classList.add('fade-out');
      document.body.classList.remove('scroll-lock');
      document.body.style.top = '';
      window.scrollTo(0, this.scrollPosition);
      setTimeout(() => {
        this.languageOverlay.style.display = 'none';
        this.languageDropdown.style.display = 'none';
        this.languageOverlay.classList.remove('fade-out');
        this.languageDropdown.classList.remove('fade-out');
        resolve();
      }, this.FADE_DURATION);
    });
  }

  /**
   * เลือกภาษา
   */
  async selectLanguage(language) {
    if (!this.languagesConfig[language]) {
      console.warn(`ไม่รองรับภาษา: ${language} กำลังใช้ภาษาอังกฤษแทน`);
      language = 'en';
    }
    if (this.selectedLang === language && !this.isNavigating) {
      await this.closeLanguageDropdown();
      return;
    }
    this.lastSelectedLang = this.selectedLang;
    await this.updatePageLanguage(language);
    await this.closeLanguageDropdown();
  }

  /**
   * อัพเดทข้อความบนปุ่มเลือกภาษา
   */
  updateButtonText() {
    if (this.languageButton) {
      this.languageButton.textContent =
        this.languagesConfig[this.selectedLang]?.buttonText || 'Language';
    }
  }

  /**
   * เก็บเนื้อหาต้นฉบับ
   */
  storeOriginalContent() {
    document.querySelectorAll('[data-translate]').forEach(el => {
      if (!el.hasAttribute('data-original-text')) {
        el.setAttribute('data-original-text', el.textContent.trim());
      }
      if (!el.hasAttribute('data-original-style')) {
        el.setAttribute('data-original-style', el.style.cssText);
      }
    });
  }

  /**
   * คืนค่าเนื้อหาเป็นภาษาอังกฤษ
   */
  async resetToEnglishContent() {
    const elements = document.querySelectorAll('[data-translate]');
    const resetPromises = Array.from(elements).map(el => new Promise(resolve => {
      requestAnimationFrame(() => {
        const originalText = el.getAttribute('data-original-text');
        const originalStyle = el.getAttribute('data-original-style');
        if (originalText) {
          this.replaceTextOnly(el, originalText);
        }
        if (originalStyle) {
          el.style.cssText = originalStyle;
        }
        resolve();
      });
    }));
    await Promise.all(resetPromises);
  }

  /**
   * ตรวจสอบความถูกต้องของข้อมูลภาษา
   */
  validateLanguageData(data) {
    return data &&
      typeof data === 'object' &&
      Object.keys(data).length > 0 &&
      Object.values(data).every(text =>
        typeof text === 'string' && text.trim().length > 0
      );
  }

  /**
   * กลับไปใช้ภาษาเริ่มต้น (อังกฤษ)
   */
  async fallbackToDefaultLanguage() {
    this.selectedLang = 'en';
    await this.resetToEnglishContent();
    this.updateButtonText();
    this.updateURLAndHistory('en');
    localStorage.setItem('selectedLang', 'en');
  }

  /**
   * แสดงข้อความแจ้งเตือนพร้อม animation
   */
  showError(message) {
    const errorDiv = document.createElement('div');
    errorDiv.className = 'language-error';
    errorDiv.textContent = message;
    Object.assign(errorDiv.style, {
      position: 'fixed',
      top: '20px',
      right: '20px',
      backgroundColor: '#ff4444',
      color: 'white',
      padding: '10px 20px',
      borderRadius: '4px',
      zIndex: '9999',
      opacity: '0',
      transition: 'opacity 0.3s ease'
    });
    document.body.appendChild(errorDiv);
    requestAnimationFrame(() => {
      errorDiv.style.opacity = '1';
      setTimeout(() => {
        errorDiv.style.opacity = '0';
        setTimeout(() => errorDiv.remove(), this.FADE_DURATION);
      }, 3000);
    });
  }

  /**
   * สังเกตการเปลี่ยนแปลงของ DOM ด้วย throttling (50ms)
   */
  observeMutations() {
    if (this.mutationObserver) { this.mutationObserver.disconnect(); }
    this.mutationObserver = new MutationObserver((mutations) => {
      if (this.mutationThrottleTimeout) return;
      this.mutationThrottleTimeout = setTimeout(() => {
        let needsUpdate = false;
        mutations.forEach(mutation => {
          if (mutation.type === 'childList') {
            mutation.addedNodes.forEach(node => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                const translatableElements = node.querySelectorAll('[data-translate]');
                if (translatableElements.length > 0) {
                  needsUpdate = true;
                  translatableElements.forEach(el => {
                    if (!el.hasAttribute('data-original-text')) {
                      el.setAttribute('data-original-text', el.textContent.trim());
                    }
                  });
                }
              }
            });
          }
        });
        if (needsUpdate && this.selectedLang !== 'en') {
          this.updatePageLanguage(this.selectedLang, { updateHistory: false });
        }
        this.mutationThrottleTimeout = null;
      }, 50);
    });
    this.mutationObserver.observe(document.body, { childList: true, subtree: true });
  }

  /**
   * ทำความสะอาดและยกเลิกการทำงานของ LanguageManager
   */
  destroy() {
    if (this.languageButton) this.languageButton.remove();
    if (this.languageOverlay) this.languageOverlay.remove();
    if (this.languageDropdown) this.languageDropdown.remove();
    if (this.mutationObserver) this.mutationObserver.disconnect();
    if (this.htmlLangObserver) this.htmlLangObserver.disconnect();
    this.languageCache.clear();
    this.isInitialized = false;
    this.isLanguageDropdownOpen = false;
    this.isUpdatingLanguage = false;
    this.isNavigating = false;
  }
}

// สร้าง instance และเริ่มต้นการทำงาน
const languageManager = new LanguageManager();

// เริ่มต้นระบบเมื่อโหลดหน้าเว็บ
window.addEventListener('DOMContentLoaded', () => {
  languageManager.initialize();
});

// Export สำหรับการใช้งานภายนอก
if (typeof module !== 'undefined' && module.exports) {
  module.exports = languageManager;
}