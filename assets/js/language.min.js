/**
 * LanguageManager Ultra-Enterprise: Opacity-Gated Render Edition (SVG/IMG safe)
 * - สำหรับเพจที่ต้องแปลภาษา ให้ <body style="opacity:0"> ไว้ใน HTML
 * - เมื่อโหลด/แปล/ทุกอย่างเสร็จจะ set body.style.opacity = "1"
 * - ยังคง parallel/worker pool/IndexedDB/auto-detect language/UX เหมือนเดิม
 * - **ปรับปรุง: แปลภาษาโดยไม่ลบ/แตะต้อง IMG, SVG หรือ element อื่นที่ไม่ใช่ text**
 * - ยังรองรับ anchor tag translation ตามเดิม
 * - ไม่แตะ logic อื่นๆ ที่ไม่เกี่ยวข้อง
 */

// --- NOTE ---
// คุณต้องใส่ <body style="opacity:0"> ใน HTML สำหรับหน้าเว็บที่ต้องการ
// -----------------

//////////////////// IndexedDB Utilities: Parallel/Batch ////////////////////
const DB_NAME = "LanguageCacheDB";
const DB_STORE = "langs";
const DB_VERSION = 1;
function openLangDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onerror = () => reject(req.error);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(DB_STORE)) {
        db.createObjectStore(DB_STORE, { keyPath: "key" });
      }
    };
    req.onsuccess = () => resolve(req.result);
  });
}
async function getLangCacheBatch(langKeys) {
  const db = await openLangDB();
  return await Promise.all(langKeys.map(langKey => {
    return new Promise(resolve => {
      const tx = db.transaction(DB_STORE, "readonly");
      const store = tx.objectStore(DB_STORE);
      const req = store.get(langKey);
      req.onsuccess = () => resolve(req.result ? req.result.data : null);
      req.onerror = () => resolve(null);
    });
  }));
}
async function setLangCacheBatch(langDatas) {
  const db = await openLangDB();
  return await Promise.all(langDatas.map(({ langKey, data }) => {
    return new Promise(resolve => {
      const tx = db.transaction(DB_STORE, "readwrite");
      const store = tx.objectStore(DB_STORE);
      store.put({ key: langKey, data, ts: Date.now() });
      tx.oncomplete = () => resolve();
      tx.onerror = () => resolve();
    });
  }));
}

//////////////////// Worker Pool: True Parallel Batch ////////////////////
class WorkerPool {
  constructor(workerCode, poolSize) {
    this.workers = [];
    this.idle = [];
    this.jobs = [];
    this.poolSize = poolSize;
    for (let i = 0; i < poolSize; ++i) {
      const blob = new Blob([workerCode], { type: "application/javascript" });
      const url = URL.createObjectURL(blob);
      const worker = new Worker(url);
      worker.onmessage = (e) => this._onMessage(worker, e);
      this.workers.push(worker);
      this.idle.push(worker);
    }
    this.jobMap = new Map();
  }
  execute(data) {
    return new Promise((resolve, reject) => {
      const job = { data, resolve, reject };
      if (this.idle.length > 0) {
        const worker = this.idle.pop();
        this._runJob(worker, job);
      } else {
        this.jobs.push(job);
      }
    });
  }
  _runJob(worker, job) {
    this.jobMap.set(worker, job);
    worker.postMessage(job.data);
  }
  _onMessage(worker, e) {
    const job = this.jobMap.get(worker);
    this.jobMap.delete(worker);
    job.resolve(e.data);
    this.idle.push(worker);
    if (this.jobs.length > 0) {
      const nextJob = this.jobs.shift();
      this._runJob(worker, nextJob);
    }
  }
  destroy() {
    this.workers.forEach(w => w.terminate && w.terminate());
    this.workers = [];
    this.idle = [];
    this.jobs = [];
    this.jobMap.clear();
  }
}

//////////////////// Main LanguageManager ////////////////////
class LanguageManager {
  constructor() {
    this.languagesConfig = {};
    this.selectedLang = "";
    this.lastSelectedLang = "";
    this.isLanguageDropdownOpen = false;
    this.languageCache = {};
    this.isUpdatingLanguage = false;
    this.isNavigating = false;
    this.mutationObserver = null;
    this.scrollPosition = 0;
    this.isInitialized = false;
    this.mutationThrottleTimeout = null;
    this.FADE_DURATION = 300;

    this.maxWorker = navigator.hardwareConcurrency ? Math.max(4, Math.floor(navigator.hardwareConcurrency * 0.9)) : 8;
    const workerCode = `
      self.onmessage = function(e) {
        const { nodes, langData, batchIdx } = e.data;
        const result = [];
        for (let i=0;i<nodes.length;i++) {
          const { key, html, aMeta } = nodes[i];
          let translation = langData[key] || '';
          translation = translation.replace(/@br/g, "<br>");
          translation = translation.replace(/@strong(.*?)@/g, "<strong>$1</strong>");
          // If translation has @a...@ marker, split and return as array for anchor mapping
          let anchorMatches = [];
          let newHTML = translation;
          if (/@a(.*?)@/g.test(translation)) {
            anchorMatches = [];
            let match, aTagRegex = /@a(.*?)@/g;
            while ((match = aTagRegex.exec(translation)) !== null) anchorMatches.push(match[1]);
            newHTML = translation.replace(/@a(.*?)@/g, '@a@');
          }
          result.push({ idx: i, html: newHTML, anchors: anchorMatches });
        }
        self.postMessage({ batchIdx, result });
      }
    `;
    this.workerPool = new WorkerPool(workerCode, this.maxWorker);

    this._prefetchPromise = this.prefetchEnterprise();
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => this.initialize());
    } else {
      this.initialize();
    }
  }

  async prefetchEnterprise() {
    if (typeof document !== "undefined" && document.head) {
      ["//cdn.jsdelivr.net", "//fonts.googleapis.com"].forEach(href => {
        if (!document.head.querySelector(`link[href^="${href}"]`)) {
          const l = document.createElement("link");
          l.rel = "preconnect";
          l.href = href;
          l.crossOrigin = "anonymous";
          document.head.appendChild(l);
        }
      });
      if (!document.head.querySelector('link[rel="preload"][as="fetch"]')) {
        const preload = document.createElement("link");
        preload.rel = "preload";
        preload.as = "fetch";
        preload.href = "/assets/json/language.min.json";
        preload.crossOrigin = "anonymous";
        document.head.appendChild(preload);
      }
    }
    let config = null;
    const localConfigRaw = localStorage.getItem('__lang_cfg');
    const sessionConfigRaw = sessionStorage.getItem('__lang_cfg');
    if (localConfigRaw) try { config = JSON.parse(localConfigRaw); } catch {}
    if (!config && sessionConfigRaw) try { config = JSON.parse(sessionConfigRaw); } catch {}

    const fetchConfigPromise = fetch('/assets/json/language.min.json', {
      cache: 'reload',
      priority: 'high',
      keepalive: true,
      headers: { "Accept-Encoding": "gzip, br" }
    }).then(r => r.json()).catch(() => null);

    config = config || await Promise.race([
      fetchConfigPromise,
      new Promise(r => setTimeout(() => r(null), 20))
    ]);
    if (!config) config = await fetchConfigPromise;
    if (config) {
      localStorage.setItem('__lang_cfg', JSON.stringify(config));
      sessionStorage.setItem('__lang_cfg', JSON.stringify(config));
      this.languagesConfig = config;
    }
    this.prepareAllButtonTexts();
  }

  async enterpriseLoadLang(lang) {
    if (this.languageCache[lang]) return this.languageCache[lang];
    const langKey = lang + "_v1";
    const cachePromise = getLangCacheBatch([langKey]).then(resArr => resArr[0]);
    const fetchPromise = fetch(`/assets/lang/${lang}.min.json`, {
      cache: 'reload',
      priority: 'high',
      keepalive: true,
      headers: { "Accept-Encoding": "gzip, br" }
    }).then(async resp => {
      let data;
      if ("body" in resp && window.ReadableStream) {
        const reader = resp.body.getReader();
        let text = "", done = false, value;
        while (!done) {
          ({ done, value } = await reader.read());
          if (value) text += new TextDecoder().decode(value);
        }
        data = this.flattenLanguageJson(JSON.parse(text));
      } else {
        data = this.flattenLanguageJson(await resp.json());
      }
      await setLangCacheBatch([{ langKey, data }]);
      return data;
    }).catch(() => null);

    let data = await Promise.race([
      cachePromise.then(res => res || new Promise(r => setTimeout(() => r(null), 8))),
      fetchPromise
    ]);
    if (!data) data = await fetchPromise;
    if (data) this.languageCache[lang] = data;
    return data;
  }

  flattenLanguageJson(json) {
    const result = {};
    function recur(obj) {
      for (const [k, v] of Object.entries(obj)) {
        if (typeof v === 'object' && v !== null) recur(v);
        else result[k] = v;
      }
    }
    recur(json);
    return result;
  }

  async prepareAllButtonTexts() {
    this.languageButton = document.getElementById('language-button');
    if (!this.languageButton || !this.languagesConfig) return;
    Array.from(this.languageButton.querySelectorAll('.lang-btn-txt')).forEach(e => e.remove());
    Object.entries(this.languagesConfig).forEach(([lang, config]) => {
      const span = document.createElement('span');
      span.className = 'lang-btn-txt';
      span.dataset.lang = lang;
      span.textContent = config.buttonText || 'Language';
      span.style.display = 'none';
      this.languageButton.appendChild(span);
    });
    this.showButtonTextForLang(this.selectedLang || 'en');
  }
  showButtonTextForLang(lang) {
    this.languageButton = document.getElementById('language-button');
    if (!this.languageButton) return;
    Array.from(this.languageButton.querySelectorAll('.lang-btn-txt')).forEach(span => {
      span.style.display = (span.dataset.lang === lang) ? '' : 'none';
    });
  }
  updateLanguageSelectorUI() { this.initializeCustomLanguageSelector(); }

  detectBrowserLanguage() {
    if (!this.languagesConfig) return 'en';
    const browserLanguages = navigator.languages || [navigator.language || navigator.userLanguage];
    for (const lang of browserLanguages) {
      const langCode = lang.split('-')[0];
      if (this.languagesConfig[langCode]) return langCode;
    }
    return 'en';
  }

  async handleInitialLanguage() {
    this.storeOriginalContent();
    const urlParams = new URLSearchParams(window.location.search);
    const langFromUrl = urlParams.get('lang');
    const storedLang = localStorage.getItem('selectedLang');
    let autoLang = this.detectBrowserLanguage();
    this.selectedLang =
      (langFromUrl && this.languagesConfig[langFromUrl]) ? langFromUrl :
      (storedLang && this.languagesConfig[storedLang]) ? storedLang :
      (this.languagesConfig[autoLang] ? autoLang : 'en');
    this.showButtonTextForLang(this.selectedLang);
    if (this.selectedLang !== 'en') {
      await this.updatePageLanguage(this.selectedLang, { updateHistory: false });
    }
  }
  async loadLanguagesConfig() {
    await this._prefetchPromise;
    if (!this.languagesConfig || !Object.keys(this.languagesConfig).length)
      throw new Error("Config ไม่ถูกต้องและโหลดใหม่ไม่ได้");
    await this.prepareAllButtonTexts();
    await this.handleInitialLanguage();
    this.updateLanguageSelectorUI();
  }
  async loadLanguageData(lang) { return await this.enterpriseLoadLang(lang); }

  async initialize() {
    if (this.isInitialized) return;
    try {
      await this.loadLanguagesConfig();
      this.observeMutations();
      this.setupNavigationHandlers();
      document.documentElement.setAttribute("lang", "");
      this.isInitialized = true;
      setTimeout(() => {
        if (document.body && document.body.style.opacity === "0") {
          document.body.style.transition = "opacity 0.28s cubic-bezier(.47,1.64,.41,.8)";
          document.body.style.opacity = "1";
        }
      }, 0);
    } catch (error) {
      console.error('Error during initialization:', error);
      this.showError('ไม่สามารถเริ่มต้นระบบได้');
      setTimeout(() => {
        if (document.body && document.body.style.opacity === "0") {
          document.body.style.opacity = "1";
        }
      }, 0);
    }
  }

  async updatePageLanguage(language, options = { updateHistory: true }) {
    if (this.isUpdatingLanguage) return;
    try {
      this.isUpdatingLanguage = true;
      this.lastSelectedLang = this.selectedLang;
      document.documentElement.setAttribute("lang", "");
      document.documentElement.setAttribute("lang", language);
      if (language === this.detectBrowserLanguage()) {
        document.documentElement.setAttribute("translate", "no");
        if (!document.querySelector('meta[name="google"][content="notranslate"]')) {
          const meta = document.createElement('meta');
          meta.name = "google";
          meta.content = "notranslate";
          document.head.appendChild(meta);
        }
      } else {
        document.documentElement.removeAttribute("translate");
        const meta = document.querySelector('meta[name="google"][content="notranslate"]');
        if (meta) { meta.remove(); }
      }
      if (language === 'en') {
        await this.resetToEnglishContent();
      } else {
        const languageData = await this.loadLanguageData(language);
        if (languageData) {
          await this.parallelStreamingTranslate(languageData);
        } else {
          await this.resetToEnglishContent();
        }
      }
      this.selectedLang = language;
      this.showButtonTextForLang(this.selectedLang);
      if (options.updateHistory) this.updateURLAndHistory(language);
      localStorage.setItem('selectedLang', language);
    } catch (error) {
      console.error('Error updating page language:', error);
      this.showError('เกิดข้อผิดพลาดในการเปลี่ยนภาษา');
      await this.resetToEnglishContent();
    } finally {
      this.isUpdatingLanguage = false;
    }
  }
  updateURLAndHistory(language) {
    const url = new URL(window.location.href);
    if (language === 'en') url.searchParams.delete('lang');
    else url.searchParams.set('lang', language);
    const newUrl = url.toString();
    if (newUrl === window.location.href) return;
    const state = { language, lastLanguage: this.lastSelectedLang, timestamp: Date.now() };
    history.replaceState(state, '', newUrl);
  }
  setupNavigationHandlers() {
    window.addEventListener('popstate', async (event) => {
      if (this.isLanguageDropdownOpen) await this.closeLanguageDropdown();
      if (this.isNavigating) return;
      this.isNavigating = true;
      try {
        const storedLang = localStorage.getItem('selectedLang') || 'en';
        if (storedLang !== this.selectedLang) {
          await this.updatePageLanguage(storedLang, { updateHistory: false });
        }
      } finally {
        this.isNavigating = false;
      }
    });
  }

  /**
   * แปลภาษาโดยไม่ลบ/แตะต้อง <img>, <svg> หรือ child node อื่นที่ไม่ใช่ text/a
   * - ถ้ามี <a> ให้เปลี่ยนเฉพาะ textContent ของ <a>
   * - ถ้าไม่มี <a> ให้แปะ text ใน text node ที่ไม่ใช่ img/svg
   */
  async parallelStreamingTranslate(languageData, elements) {
    const elList = elements || Array.from(document.querySelectorAll('[data-translate]'));
    if (!elList.length) return;
    const chunkSize = Math.max(8, Math.ceil(elList.length / this.maxWorker));
    const batches = [];
    const nodeMeta = [];
    for (let i = 0; i < elList.length; i += chunkSize) {
      const batch = elList.slice(i, i + chunkSize);
      batches.push(batch);
      nodeMeta.push(batch.map(el => ({
        key: el.getAttribute('data-translate'),
        html: el.innerHTML,
        aMeta: Array.from(el.querySelectorAll('a')).map(a => a.textContent)
      })));
    }
    const jobs = nodeMeta.map((meta, i) =>
      this.workerPool.execute({ nodes: meta, langData: languageData, batchIdx: i })
    );
    const results = await Promise.all(jobs);
    for (let j = 0; j < results.length; ++j) {
      const batch = batches[j], resArr = results[j].result;
      for (let k = 0; k < resArr.length; ++k) {
        const el = batch[resArr[k].idx];
        if (!el) continue;
        const { html, anchors } = resArr[k];
        // ถ้ามี <a> และ anchor marker ให้เปลี่ยนเฉพาะ textContent
        const aEls = Array.from(el.querySelectorAll('a'));
        if (anchors && anchors.length && aEls.length) {
          // หาจำนวน marker (@a@) ใน html (string)
          let htmlParts = html.split('@a@');
          // แทรก <a> ระหว่าง htmlParts ตามตำแหน่งเดิม
          let frag = document.createDocumentFragment();
          htmlParts.forEach((part, idx) => {
            if (part) frag.appendChild(document.createTextNode(part));
            if (anchors[idx] !== undefined && aEls[idx]) {
              // แทนที่เฉพาะ textContent ของ <a>
              let aClone = aEls[idx].cloneNode(true);
              aClone.textContent = anchors[idx];
              frag.appendChild(aClone);
            }
          });
          // ลบทุก child node ที่เป็น text/a เท่านั้น (ไม่แตะ img/svg/element อื่น)
          Array.from(el.childNodes).forEach(node => {
            if (
              node.nodeType === Node.TEXT_NODE ||
              (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'A')
            ) el.removeChild(node);
          });
          el.insertBefore(frag, el.firstChild);
        } else {
          // ไม่มี <a> หรือไม่มี anchor marker: replace เฉพาะ text/text node, ไม่แตะ img/svg
          this.replaceTextOnly(el, html.replace(/@a@/g, ""));
        }
      }
    }
  }

  // ปรับใหม่: replace เฉพาะ text node/textContent ไม่ลบ/แตะต้อง img/svg/element อื่น
  replaceTextOnly(element, newText) {
    let replaced = false;
    element.childNodes.forEach((node) => {
      if (replaced) return;
      if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
        node.textContent = newText;
        replaced = true;
      } else if (
        node.nodeType === Node.ELEMENT_NODE &&
        !['IMG', 'SVG', 'A'].includes(node.tagName)
      ) {
        this.replaceTextOnly(node, newText);
      }
    });
    // ถ้าไม่มี text node เลย ให้เพิ่มใหม่
    if (!replaced && newText) {
      element.insertBefore(document.createTextNode(newText), element.firstChild);
    }
  }

  // ----------- UI/UX unchanged below -----------
  initializeCustomLanguageSelector() {
    const container = document.getElementById('language-selector-container');
    this.languageButton = document.getElementById('language-button');
    if (!this.languageButton) return;
    this.prepareAllButtonTexts();
    this.showButtonTextForLang(this.selectedLang || 'en');
    if (this.languageOverlay && this.languageOverlay.parentElement) {
      this.languageOverlay.parentElement.removeChild(this.languageOverlay);
      this.languageOverlay = null;
    }
    if (this.languageDropdown && this.languageDropdown.parentElement) {
      this.languageDropdown.parentElement.removeChild(this.languageDropdown);
      this.languageDropdown = null;
    }
    this.languageOverlay = document.createElement('div');
    this.languageOverlay.id = 'language-overlay';
    document.body.appendChild(this.languageOverlay);
    this.languageDropdown = document.createElement('div');
    this.languageDropdown.id = 'language-dropdown';
    this.languageDropdown.innerHTML = '';
    this.populateLanguageDropdown();
    document.body.appendChild(this.languageDropdown);
    this.setupEventListeners();
    this.setupDropdownScrollLock();
  }
  populateLanguageDropdown() {
    const fragment = document.createDocumentFragment();
    Object.entries(this.languagesConfig).forEach(([lang, config]) => {
      const option = document.createElement('div');
      option.className = 'language-option';
      option.textContent = config.label;
      option.dataset.language = lang;
      fragment.appendChild(option);
    });
    this.languageDropdown.innerHTML = '';
    this.languageDropdown.appendChild(fragment);
  }
  setupEventListeners() {
    if (!this.languageButton) return;
    this.languageButton.onclick = () => this.toggleLanguageDropdown();
    this.languageOverlay.onclick = () => this.closeLanguageDropdown();
    this.languageDropdown.onclick = (e) => {
      const option = e.target.closest('.language-option');
      if (option) {
        const lang = option.dataset.language;
        if (lang) this.selectLanguage(lang);
      }
    };
  }
  setupDropdownScrollLock() {
    if (!this.languageDropdown) return;
    this.languageDropdown.removeEventListener('wheel', this._dropdownWheelListener, { passive: false });
    this.languageDropdown.removeEventListener('touchstart', this._dropdownTouchStartListener);
    this.languageDropdown.removeEventListener('touchmove', this._dropdownTouchMoveListener, { passive: false });
    this._dropdownWheelListener = (e) => {
      const el = this.languageDropdown;
      const delta = e.deltaY;
      const atTop = el.scrollTop === 0;
      const atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 1;
      if ((atTop && delta < 0) || (atBottom && delta > 0)) e.preventDefault();
      e.stopPropagation();
    };
    this.languageDropdown.addEventListener('wheel', this._dropdownWheelListener, { passive: false });
    let lastY = 0;
    this._dropdownTouchStartListener = (e) => {
      if (e.touches.length === 1) lastY = e.touches[0].clientY;
    };
    this._dropdownTouchMoveListener = (e) => {
      if (e.touches.length !== 1) return;
      const el = this.languageDropdown;
      const currentY = e.touches[0].clientY;
      const delta = lastY - currentY;
      lastY = currentY;
      const atTop = el.scrollTop === 0;
      const atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 1;
      if ((atTop && delta < 0) || (atBottom && delta > 0)) e.preventDefault();
      e.stopPropagation();
    };
    this.languageDropdown.addEventListener('touchstart', this._dropdownTouchStartListener);
    this.languageDropdown.addEventListener('touchmove', this._dropdownTouchMoveListener, { passive: false });
  }
  toggleLanguageDropdown() {
    this.isLanguageDropdownOpen ? this.closeLanguageDropdown() : this.openLanguageDropdown();
  }
  async openLanguageDropdown() {
    if (this.isLanguageDropdownOpen) return;
    this.scrollPosition = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;
    this.isLanguageDropdownOpen = true;
    this.languageOverlay.style.display = 'block';
    this.languageDropdown.style.display = 'block';
    document.body.style.position = 'fixed';
    document.body.style.left = '0';
    document.body.style.right = '0';
    document.body.style.overflowY = 'scroll';
    document.body.style.top = `-${this.scrollPosition}px`;
    document.body.classList.add('scroll-lock');
    return new Promise(resolve => {
      requestAnimationFrame(() => {
        this.languageOverlay.classList.add('fade-in');
        this.languageDropdown.classList.add('fade-in');
        setTimeout(resolve, this.FADE_DURATION);
      });
    });
  }
  async closeLanguageDropdown() {
    if (!this.isLanguageDropdownOpen) return;
    const dropdownResetDelay = 80;
    return new Promise(resolve => {
      this.isLanguageDropdownOpen = false;
      this.languageOverlay.classList.remove('fade-in');
      this.languageDropdown.classList.remove('fade-in');
      this.languageOverlay.classList.add('fade-out');
      this.languageDropdown.classList.add('fade-out');
      document.body.classList.remove('scroll-lock');
      document.body.style.position = '';
      document.body.style.left = '';
      document.body.style.right = '';
      document.body.style.overflowY = '';
      document.body.style.top = '';
      window.scrollTo(0, this.scrollPosition);
      setTimeout(() => {
        if (this.languageDropdown) {
          this.languageDropdown.scrollTop = 0;
          this.languageDropdown.scrollLeft = 0;
        }
      }, this.FADE_DURATION - dropdownResetDelay);
      setTimeout(() => {
        this.languageOverlay.style.display = 'none';
        this.languageDropdown.style.display = 'none';
        this.languageOverlay.classList.remove('fade-out');
        this.languageDropdown.classList.remove('fade-out');
        resolve();
      }, this.FADE_DURATION);
    });
  }
  async selectLanguage(language) {
    if (!this.languagesConfig[language]) {
      console.warn(`ไม่รองรับภาษา: ${language} กำลังใช้ภาษาอังกฤษแทน`);
      language = 'en';
    }
    if (this.selectedLang === language && !this.isNavigating) {
      await this.closeLanguageDropdown();
      return;
    }
    this.lastSelectedLang = this.selectedLang;
    await this.updatePageLanguage(language);
    await this.closeLanguageDropdown();
  }
  storeOriginalContent() {
    document.querySelectorAll('[data-translate]').forEach(el => {
      if (!el.hasAttribute('data-original-text')) {
        el.setAttribute('data-original-text', el.textContent.trim());
      }
      if (!el.hasAttribute('data-original-style')) {
        el.setAttribute('data-original-style', el.style.cssText);
      }
    });
  }
  async resetToEnglishContent() {
    const elements = document.querySelectorAll('[data-translate]');
    const resetPromises = Array.from(elements).map(el => new Promise(resolve => {
      requestAnimationFrame(() => {
        const originalText = el.getAttribute('data-original-text');
        const originalStyle = el.getAttribute('data-original-style');
        if (originalText) {
          this.replaceTextOnly(el, originalText);
        }
        if (originalStyle) {
          el.style.cssText = originalStyle;
        }
        resolve();
      });
    }));
    await Promise.all(resetPromises);
  }
  showError(message) {
    const errorDiv = document.createElement('div');
    errorDiv.className = 'language-error';
    errorDiv.textContent = message;
    Object.assign(errorDiv.style, {
      position: 'fixed',
      top: '20px',
      right: '20px',
      backgroundColor: '#ff4444',
      color: 'white',
      padding: '10px 20px',
      borderRadius: '4px',
      zIndex: '9999',
      opacity: '0',
      transition: 'opacity 0.3s ease'
    });
    document.body.appendChild(errorDiv);
    requestAnimationFrame(() => {
      errorDiv.style.opacity = '1';
      setTimeout(() => {
        errorDiv.style.opacity = '0';
        setTimeout(() => errorDiv.remove(), this.FADE_DURATION);
      }, 3000);
    });
  }
  observeMutations() {
    if (this.mutationObserver) { this.mutationObserver.disconnect(); }
    this.mutationObserver = new MutationObserver((mutations) => {
      if (this.mutationThrottleTimeout) return;
      this.mutationThrottleTimeout = setTimeout(() => {
        let needsUpdate = false, added = [];
        mutations.forEach(mutation => {
          if (mutation.type === 'childList') {
            mutation.addedNodes.forEach(node => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                const translatableElements = node.querySelectorAll('[data-translate]');
                if (translatableElements.length > 0) {
                  needsUpdate = true;
                  added.push(...translatableElements);
                  translatableElements.forEach(el => {
                    if (!el.hasAttribute('data-original-text')) {
                      el.setAttribute('data-original-text', el.textContent.trim());
                    }
                  });
                }
              }
            });
          }
        });
        if (needsUpdate && this.selectedLang !== 'en') {
          this.parallelStreamingTranslate(this.languageCache[this.selectedLang], added);
        }
        this.mutationThrottleTimeout = null;
      }, 1);
    });
    this.mutationObserver.observe(document.body, { childList: true, subtree: true });
  }
  destroy() {
    if (this.languageOverlay) this.languageOverlay.remove();
    if (this.languageDropdown) this.languageDropdown.remove();
    if (this.mutationObserver) this.mutationObserver.disconnect();
    this.languageCache = {};
    this.isInitialized = false;
    this.isLanguageDropdownOpen = false;
    this.isUpdatingLanguage = false;
    this.isNavigating = false;
    if (this.workerPool) this.workerPool.destroy();
  }
}

const languageManager = new LanguageManager();
window.languageManager = languageManager;
if (typeof module !== 'undefined' && module.exports) module.exports = languageManager;